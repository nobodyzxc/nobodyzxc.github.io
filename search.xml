<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[玉山 NLP 應用挑戰賽]]></title>
    <url>%2F2020%2F08%2F15%2Faml%2F</url>
    <content type="text"><![CDATA[暑假花了一點時間和同學做起來的 project，來場經驗分享吧！ 學期末在 FB 上看到有人在人工智慧社團分享了這個比賽，感覺這個議題滿有趣的，剛好大學有修過一門 IR (Information Retrieval, 資訊檢索) 的課，他算是自然語言處理 (NLP) 的應用，所以也算對 NLP 有一點點基本的認識，手上有那時期末 project 做出來的 crawler 和 IR Model，我便拉著同學們一起入坑了。 所有的 code 都已經放在 GitHub 上了，有興趣可以參考，不過因為訓練資料是主辦單位提供，故不能釋出。這部份可能要讀者自行爬取並標記。 接著就來介紹一下這個比賽吧！ 競賽說明 About Competition 以下說明來自 玉山官網 。 Gotcha！人人都可以是反洗錢大師！ 洗錢是指將犯罪不法所得，以各種手段掩飾、隱匿而使犯罪所得在形式上合法化的行為。近年來因國際洗錢與資助恐怖活動事件頻傳，國內吸金、電信詐騙案件也層出不窮，使得政府與各產業皆致力於洗錢防制 (AML) 工作。 一般來說，顧客與金融機構往來時，銀行需即時確認顧客身份，透過自動化系統比對出顧客是否列於 AML 焦點人物名單中。若能透過 AI 的協助定期更新 AML 焦點人物名單，並搭配自動化比對，將可大幅降低銀行執行AML作業的人力與時間成本。 本次競賽將提供參賽者公開新聞資料連結與相對應的焦點人物名單，希望大家集思廣益，透過NLP演算法，精準找出 AML 相關新聞焦點人物，不僅能協助優化 AML 焦點人物名單的更新作業，更有機會獲得高額獎金！ 項目 日期 報名 06/01/2020 - 06/30/2020 測試賽 07/22/2020 正式賽 07/27/2020 - 07/30/2020 08/03/2020 - 08/06/2020 公布名次 08/12/2020 頒獎典禮 08/22/2020 簡單來說，這個比賽就是要判斷一篇文章是不是 AML 相關的新聞，如果是的話，就要把裡面的焦點人物（通常是有犯罪事實的人物）抓出來，生成一個名單。 由於是學期末看到的比賽，比賽已經開始快一個月了，又因為學期末課業繁忙，估計學期結束才能開始。算一算 7/6 才可以開始做，距離測試賽估計只有兩個禮拜，之後離正式賽也只有一個禮拜可以調整模型。不過加上先前的經驗，我想大概夠了，一方面也不想佔用太多時間在比賽上，也就抱著玩玩的心態來嘗試一下、衝刺看看。 爬蟲 Crawling有了先前的基礎，基本上只花了一個晚上就把資料都爬回來了。爬蟲是相對容易，但是需要重複性勞動的工作，以下介紹我是怎麼爬新聞的。 Basic crawling新聞網站大部份是動態網頁，通常是由伺服器端從資料庫撈內文出來套在模板上，然後回傳給 user，所以只要是同個網站的新聞，他們大多會遵照一定的排版。 pandas &amp; the domains第一步就先來看看有哪些網站的排版要抓，我們先把主辦單位提供給我們的資料透過 pandas 讀進來，接著把所有 domain 讀出來。 123456import reimport pandas as pdfrom pprint import pprintcsv = pd.read_csv('tbrain_train_final_0610.csv')webs = set(re.findall(r'(https?://)?([^/]+)', l)[0][1] for l in csv['hyperlink'])pprint(webs) 可以得到這 39 個 domain： 123456789101112131415161718192021222324252627282930313233343536373839&#123;'ccc.technews.tw', 'domestic.judicial.gov.tw', 'ec.ltn.com.tw', 'ent.ltn.com.tw', 'estate.ltn.com.tw', 'finance.technews.tw', 'hk.on.cc', 'house.ettoday.net', 'm.ctee.com.tw', 'm.ltn.com.tw', 'money.udn.com', 'mops.twse.com.tw', 'news.cnyes.com', 'news.ebc.net.tw', 'news.ltn.com.tw', 'news.mingpao.com', 'news.tvbs.com.tw', 'ol.mingpao.com', 'sina.com.hk', 'technews.tw', 'tw.news.yahoo.com', 'udn.com', 'www.bnext.com.tw', 'www.businesstoday.com.tw', 'www.chinatimes.com', 'www.cna.com.tw', 'www.coolloud.org.tw', 'www.cw.com.tw', 'www.ettoday.net', 'www.fsc.gov.tw', 'www.hbrtaiwan.com', 'www.hk01.com', 'www.managertoday.com.tw', 'www.mirrormedia.mg', 'www.nextmag.com.tw', 'www.nownews.com', 'www.setn.com', 'www.storm.mg', 'www.wealth.com.tw'&#125; beautiful soup 4 &amp; the selector有了 domain 之後就是重複性的工作了。從各個 domain 中各挑一篇新聞出來查看他的內文位置，然後寫好 selector 用 bs4 抓出來。 舉個例子：http://finance.technews.tw/2019/09/06/palo-alto-networks-intends-to-acquire-zingbox/ 按下 f12 後可以看到，此網頁的 article tag 可以涵蓋所有內文，之後我再把他 p tag 的內容抓出來就好。 把 39 個 domain 抓出來大概長這樣：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354fetch_table = &#123; # previous 'www.chinatimes.com': ['div', &#123;'class': 'article-body'&#125;], 'news.tvbs.com.tw': ['div', &#123;'id':'news_detail_div'&#125;], 'home.appledaily.com.tw': ['div', &#123;'class': 'ncbox_cont'&#125;], # current 'news.cnyes.com': ['div', &#123;'itemprop': 'articleBody'&#125;], 'www.mirrormedia.mg': ['article', &#123;&#125;], 'domestic.judicial.gov.tw': ['pre', &#123;&#125;], 'www.coolloud.org.tw': ['div', &#123;'class':'field-items'&#125;], 'm.ctee.com.tw': ['div', &#123;'class': 'entry-main'&#125;], 'mops.twse.com.tw': ['div', &#123;'id': 'zoom'&#125;], 'www.hk01.com': ['article', &#123;&#125;], 'www.wealth.com.tw': ['div', &#123;'class': 'entry-main'&#125;], 'news.ebc.net.tw': ['div', &#123;'class': 'fncnews-content'&#125;], 'news.mingpao.com': ['article', &#123;&#125;], 'www.bnext.com.tw': ['div', &#123;'class': 'content'&#125;], 'news.ltn.com.tw': ['div', &#123;'itemprop': 'articleBody'&#125;], 'finance.technews.tw': ['article', &#123;&#125;], 'www.fsc.gov.tw': ['div', &#123;'id': 'maincontent'&#125;], 'www.cw.com.tw': ['article', &#123;&#125;], 'www.businesstoday.com.tw': ['div', &#123;'class': 'article'&#125;], 'sina.com.hk': ['section', &#123;'id': 'content'&#125;], 'www.ettoday.net': ['article', &#123;&#125;], 'hk.on.cc': ['div', &#123;'class': 'breakingNewsContent'&#125;], 'technews.tw': ['div', &#123;'class': 'content'&#125;], 'money.udn.com': ['div', &#123;'id': 'article_body'&#125;], 'udn.com': ['div', &#123;'class': 'article-content__paragraph'&#125;], 'tw.news.yahoo.com': ['article', &#123;&#125;], 'www.setn.com': ['article', &#123;&#125;], 'www.managertoday.com.tw': ['body', &#123;&#125;], 'www.cna.com.tw': ['article', &#123;&#125;], 'estate.ltn.com.tw': ['div', &#123;'itemprop': 'articleBody'&#125;], 'm.ltn.com.tw': ['div', &#123;'itemprop': 'articleBody'&#125;], 'ccc.technews.tw': ['article', &#123;&#125;], 'www.hbrtaiwan.com': ['div', &#123;'class': 'article'&#125;], 'ec.ltn.com.tw': ['p', &#123;&#125;], 'www.nownews.com': ['div', &#123;'class': 'newsContainer'&#125;], 'ol.mingpao.com': ['div', &#123;'class': 'article_wrap'&#125;], 'tw.nextmgz.com': ['article', &#123;&#125;], 'www.nextmag.com.tw': ['article', &#123;&#125;], 'ent.ltn.com.tw': ['div', &#123;'class': 'text'&#125;], 'www.storm.mg': ['article', &#123;&#125;], 'house.ettoday.net': ['article', &#123;&#125;], &#125;def find_article_args_by(url): for domain in fetch_table: if domain in url: tag, attr = fetch_table[domain] return &#123; 'name': tag, 'attrs': attr &#125; print("cannot find domain pattern in", url) 以下使用 bs4 搭配上面我們抓到的資料，進行單篇資料爬取（要將上面的 code 加到下面的 code） 其實在實際狀況有滿多特殊例外需要處理，比如網站沒有回應，需要重新 get，或者一些 general case (比如只取 p tag) 不適用，就要另外再撰寫規則。 12345678910111213141516import reimport requests as rqfrom functools import reducefrom bs4 import BeautifulSoupadd = lambda a, b: a + bresc = lambda s: s.replace("\r", '').replace("", "").replace("\n", "")url = 'http://finance.technews.tw/2019/12/22/tkec-road-to-reform/'html = rq.get(url, timeout = 10).textsoup = BeautifulSoup(html, "html.parser")articles = soup.findAll(**find_article_args_by(url))paragraphs = reduce(add, [a.findChildren("p") for a in articles])paragraphs += reduce(add, [a.find_all(r'^h[1-6]$') for a in articles])content = resc(' '.join([s for s in [p.get_text().strip() for p in paragraphs]]))print(content) 抓到的文章為：1234567台灣 3C 通路龍頭燦坤，一個月之內，董事長、總經理、財務長、發言人接連離職，由老臣陳彥君迅速接任董座，他能否勵精圖治，成功改革老燦坤？ 對所有零售通路、電商業而言，11 月是最忙碌的 1 個月，業者無不打起精神為雙 11 備戰。但是，面對實體、虛擬通路競爭對手兩路夾殺的 3C 通路龍頭燦坤實業，似乎花更多力氣在打一場「內戰」。 先是上任不到 8 個月的總經理李佳峰在 11 月 18 日清晨「因個人規畫」辭職，今年 5 月甫上任的發言人蔡依玲也同時離開；12 月 12 日，上任一年多的董事長何宗原，以及 2018 年底上任的財務長徐霄菀雙雙離職。一個月之間，上至董事長、下至發言人全面大搬風，燦坤一次折損 4 位專業經理人。 何宗原曾任台灣嬌生業務總監、中國嬌生消費品產品副總裁，2018 年在燦坤創辦人吳燦坤的妻子蔡淑惠引薦下，以專業經理人身分接下燦坤董事長。 何宗原延攬了曾在台灣萊雅、台灣寶僑家品財務部門任職的徐霄菀，以及小米前台灣總經理李佳峰進入燦坤。今年 9 月，燦坤轉投資事業金鑛咖啡、燦星旅遊因虧損擴大裁員，燦坤以何宗原、李佳峰兩人名義共同發布內部信，要「以二次創業的心態共同迎接挑戰」穩定軍心，兩人甚至在 9 月舉辦活動親自向品牌商介紹燦坤的轉型計畫，但隨著兩人先後離職，內部改革似乎戛然而止。 4 位專業經理人接連離去，所為哪樁？也許，財報透露了些許端倪。 燦坤今年前 3 季穩住 3C 通路龍頭地位，但營收、獲利皆較 2018 年同期衰退，尤其稅後淨利更較 2018 年同期大減 27%；反觀 3C 通路老二全國電子，今年前 3 季營收卻逆勢成長 5%。因此，市場傳言何宗原離去的主因恐與「業績無起色」有關。 不過，市場也有另外一派說法指出，何的離去可能與李佳峰有關；業界人士指出，李佳峰進入燦坤後的改革計畫獲得董事會授權，但在財務執行方面，卻未取得何宗原、徐霄菀支持，導致無資金奧援的李佳峰選擇掛冠求去，董事會頗為不滿。 但也有接近燦坤的人士指出，身兼燦坤、燦星網通及燦星旅遊董事長的何宗原，花了相當多心力在轉投資金鑛咖啡、燦坤集團旗下負責研發智慧家電的燦坤先端智能，似乎「很少時間花在燦坤」。 根據閩燦坤財報，先端智能 2018 年虧損達 1,216 萬人民幣，而金鑛咖啡將轉型成咖啡豆原物料供應商；燦星旅遊也持續關閉實體店面，顯然都是需要費心的事業體，這些都成了何宗原請辭導火線。 接近燦坤的人士也對記者表示，「燦星旅遊的問題尤其嚴重」，以線上旅遊產品起家，轉往實體店舖經營的燦星旅遊，自 2015 年起總共虧損 3.73 億元；從 2018 年何接任董事長以後，帳上現金從 2018 年第三季的 3.43 億元到今年第三季只剩下 1 億元。 旅遊業者指出，燦星雖然試圖反攻實體店，但最後功敗垂成，其他旅行社逐漸走向精緻化路線經營時，燦星沒有追上這股潮流，該業者表示：「業界對他們的觀感，就是成本壓得非常低，品質也不好。」 只是，就在眾人還未反應過來時，12 月 13 日，燦坤火速召開董事會，選出老臣陳彥君新任燦坤董事長。 陳彥君十多年前就在燦坤任職，曾任發言人、財務長、風控長及財務總經理，雖曾短暫到特力和樂擔任副董事長，最後又回到燦坤體系，擔任燦星網通、燦星旅遊董事長，頗受吳燦坤夫婦信任。 （作者：王子承；全文未完，完整內容請見《今周刊》） 科技新知，時時更新 30 天內走了 4 個高階經理人，燦坤改革之路恐遇逆風？ 高層求去，財報透端倪？ 延伸閱讀： Advenced crawlingwayback machine &amp; the missing pages (404)對於一些 404 的網頁，我們可以想辦法把他找回來，比方說 wayback machine 就是一個不錯的選擇。 我是用別人寫好的這個 waybackpack，也是 python 寫的小工具，他只依賴 requests 這個額外的套件。 裝起來也很簡單： 1pip install waybackpack 使用範例就大概是這樣：1waybackpack -d wayback https://udn.com/news/story/7321/3845624 -d 是資料夾，他會自動創一個你指定名字的資料夾，然後把資料存進去。 12waybackpack -d wayback https://udn.com/news/story/7321/3845624waybackpack -d wayback https://udn.com/news/story/7321/3833161 123456789$ tree -ifF wayback | grep -v &apos;/$&apos;waybackwayback/20190524225425/udn.com/news/story/7321/3833161wayback/20190608120835/udn.com/news/story/7321/3845624wayback/20190609133509/udn.com/news/story/7321/3845624wayback/20190827225620/udn.com/news/story/7321/384562420 directories, 4 files 之後就是開個檔，然後一樣餵給剛剛寫的 crawler 即可。（把 requests.get(url) 改成 open(path)，然後 .text 改 .read()） 如果連 wayback machine 都沒有，那就手動丟搜尋引擎吧！或許有人轉載，還留著一些資料。 requests-html &amp; the dynamic pages (ajax)此次比賽給的網頁似乎沒有此種頁面，但這邊還是提一下。 有時候動態生成不是由伺服端做，而是在客戶端使用 ajax 請求內文，然後套進框架。這時候就要使用瀏覽器 js 引擎去渲染，而在 python 就必須使用額外的工具來做。 例如自由時報娛樂版是採動態生成內文，這部份可以使用 requests-html 這個 library。 只用方法不難，只要照著他的 README.md 就可以了，在此就不贅述了。 模型雛型 Naive Model根據要求，我們不難設想到這個模型大概可以分成兩個部份。 classifier 用來辨別是否為 AML 新聞。 extractor 用來提取目標人名。 以下就來介紹一下我們一開始是怎麼實作這兩個工具的。 Document Classification要把文件分兩類，首先就必須想到何謂分類。一般來說，分到同一類的東西，他們彼此的相似度會比較高，所以應用這個概念，我們只要能算出文章的相似度就可以達到分類的目標。 那該怎麼判斷兩篇文章的相似度呢？ 我們先來探討一下詞和文章的關係。 那考慮把所有新聞出現過的詞想做一個集合，或者把他想成一個向量的形式。 比如這裡有三句話，我們把他當成三篇文章，為一個 corpus，並且已經做好斷詞。 太平洋/有/颱風/生成/，/請/民眾/關注/天氣/，/嚴防/大雨/。 天氣/預報/：/氣流/影響/，/天氣/仍舊/不穩/，/留意/瞬間/大雨/。 台灣/座落/於/西/太平洋/。 斷詞在實作上我們是使用 jieba 的 search_mode。 1234567891011import jiebatext = '台灣座落於西太平洋。'print(jieba.lcut_for_search(text)) # 搜尋引擎模式# ['台灣', '座落', '於', '太平', '太平洋', '西太平洋', '。']print(jieba.lcut(text, cut_all = True)) # 全模式# ['台', '灣', '座落', '於', '西太平洋', '太平', '太平洋', '', '']print(jieba.lcut(text, cut_all = False)) # 精確模式（如沒指定 cut_all 則為默認）# ['台灣', '座落', '於', '西太平洋', '。'] 把停用詞 (stopword) 等一些常用的詞去掉，例如 請，於, 仍舊, 瞬間 一類的詞，所有詞可以表示成一個 vector。 1[太平洋, 颱風, 生成, 民眾, 關注, 天氣, 嚴防, 大雨, 預報, 氣流, 影響, 不穩, 留意, 台灣, 座落] 去掉停用詞的新文章為： 太平洋/颱風/生成/民眾/關注/天氣/嚴防/大雨 天氣/預報/氣流/影響/天氣/不穩/留意/大雨 台灣/座落/太平洋 不難想到，一個詞如果在一篇文章中出現多次，那這個詞和這篇文章的關聯度就會越高，這個就是 TF (term frequency) 的概念，一般可以計算為 該詞出現在該文章的次數 / 該篇文章的詞數。該文章的詞數為正規化的用途，避免文章過長導致某詞的頻率過高。一篇文章的 TF vector 可以當成一種特徵值。以下為三篇文章的 TF vector。 1234[太平洋, 颱風, 生成, 民眾, 關注, 天氣, 嚴防, 大雨, 預報, 氣流, 影響, 不穩, 留意, 台灣, 座落][ 1/8, 1/8, 1/8, 1/8, 1/8, 1/8, 1/8, 1/8, 0, 0, 0, 0, 0, 0, 0][ 0, 0, 0, 0, 0, 2/8, 0, 1/8, 1/8, 1/8, 1/8, 1/8, 1/8, 0, 0][ 1/3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1/3, 1/3] 用 TF 的直覺大概就是如果兩篇文章擁有相同的詞越多，那相似度可能就越高。 我們可以用 cosine similarity 來計算三篇文章的相似度： \cos (t,e)= {t e \over \|t\| \| e\|} = \frac{ \sum_{i=1}^{n}{t_i e_i} }{ \sqrt{\sum_{i=1}^{n}{(t_i)^2} } \sqrt{\sum_{i=1}^{n}{(e_i)^2} } }12345from sklearn.metrics.pairwise import cosine_similarityvecA = [1/8, 1/8, 1/8, 1/8, 1/8, 1/8, 1/8, 1/8, 0, 0, 0, 0, 0, 0, 0]vecB = [ 0, 0, 0, 0, 0, 2/8, 0, 1/8, 1/8, 1/8, 1/8, 1/8, 1/8, 0, 0]vecC = [1/3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1/3, 1/3]print(cosine_similarity([vecA, vecB, vecC], [vecA, vecB, vecC])) 1234# a b c[[1. 0.3354102 0.20412415] # a [0.3354102 1. 0. ] # b [0.20412415 0. 1. ]] # c 而更進一步考慮，一個詞他在只出現在某幾篇新聞中（比如 “洗錢”）和一個詞幾乎每篇都有（比如 “記者”），那前者的重要性和獨特性應該會比後者高。這就是 IDF（inverse document frequency，逆向文件頻率）的概念，一般計算為 log(所有的文章數目 / 出現該詞的文章數 + 1)。 1234log(3 / (2)) = 0.4 # 這邊因為 corpus 小，而且詞都有出現，所以就不做 + 1 避免分母為零log(3 / (1)) = 1.1[太平洋, 颱風, 生成, 民眾, 關注, 天氣, 嚴防, 大雨, 預報, 氣流, 影響, 不穩, 留意, 台灣, 座落][ 0.4, 1.1, 1.1, 1.1, 1.1, 0.4, 1.1, 0.4, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1] IDF 可以表達出一個詞的特徵值，我們把他與 TF 相乘，便可得到更有意義的特徵值。 1234[太平洋, 颱風, 生成, 民眾, 關注, 天氣, 嚴防, 大雨, 預報, 氣流, 影響, 不穩, 留意, 台灣, 座落][ 0.05, 0.21,0.21,0.21,0.21, 0.05,0.21, 0.05, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0][ 0.0, 0.0, 0.0, 0.0, 0.0, 0.1, 0.0, 0.05,0.21,0.21, 0.21,0.21,0.21, 0.0, 0.0][ 0.13, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.55, 0.55] 我們一樣計算 cosine similarity 可得： 1234# a b c[[1. 0.03368042 0.01800272] # a [0.03368042 1. 0. ] # b [0.01800272 0. 1. ]] # c BM25 + w2v + IR model as classifierIR model 大概就是以上面提到提到的概念，做出的一個搜尋引擎。給定一段文字，他能幫你按照關聯度排序，把關聯度高的文章排到前面。 而我們之前所作的 model 使用的特徵值是 bm25，加上 word2vector (word2vector 是一種 word embedding 的實作，透過 unsupervised learning 產出，透過類神經網路，藉由鄰近詞算出一個詞的特徵值），最後再做個 Relevance Feedback (精準點來說，是 盲式反饋 ) 來完成 IR 任務。 那如何用這個 model 當作 classifier 呢？可以把主辦單位給的三百多篇 AML 新聞接起來，直接和要預測的文章算相似度，這邊可能就要抓一個相似度的 threshold 來判斷是或不是。 或者我們採取了一個比較簡單的作法，直接利用 IR model，取前三百篇，看這三百篇裡面，主辦單位標記的 AML 文章 recall 是多少。一樣也要取個 threshold。這邊我們大概就用三百篇和其他非 AML 相關新聞的 recall 下去抓，其實已經有不錯的分類能力了，不過還是有些新聞，例如大樂透開獎會歸進 AML 新聞。 1234567891011121314[ x 0 / 300 = 0.000000 score = 0.00 ] Query29: 【2019理財大事5】跌破...[ x 11 / 300 = 0.036667 score = 5.58 ] Query30: 公開資訊觀測站...[ v 223 / 300 = 0.743333 score = 195.94 ] Query31: 涉貪圖利 東檢聲押前台...[ x 0 / 300 = 0.000000 score = 0.00 ] Query32: 昂山素姬明出席國際法 ...[ x 0 / 300 = 0.000000 score = 0.00 ] Query33: 繼思想改造集中營之後 ...[ x 0 / 300 = 0.000000 score = 0.00 ] Query34: 山頂纜車機件故障暫停 ...[ v 251 / 300 = 0.836667 score = 215.47 ] Query35: 直銷妹誆「1年帶你住帝...[ v 262 / 300 = 0.873333 score = 224.46 ] Query36: 潤寅詐貸案延燒 上市公...[ v 206 / 300 = 0.686667 score = 179.18 ] Query37: 花蓮縣3議員涉收賄 貪 ...[ x 0 / 300 = 0.000000 score = 0.00 ] Query38: 週三晚起東北季風增強 ...[ x 0 / 300 = 0.000000 score = 0.00 ] Query39: 「灰天鵝」拉警報 | An...[ x 1 / 300 = 0.003333 score = 0.61 ] Query40: 柯媽爆料：柯文哲絕對 ...[ x 0 / 300 = 0.000000 score = 0.00 ] Query41: 媒體：特朗普涉嫌威脅 ...[ x 0 / 300 = 0.000000 score = 0.00 ] Query42: 國銀海外投資豐收 8月O... Named Entity Recognition人名提取是本次比賽的重點。在 NLP 中 Named Entity Recognition 可以識別出特殊的名詞，例如人物、組織和地點等。 NN model (ckip) + rule based as extractor (NER)而在去年九月，中研院的 ckip 開源了一套新的斷詞系統 ckiptagger，與舊的不同處在於這一套是用深度學習的方法，利用 BiLSTM 訓練出來的模型。他一樣利用 pre-training 的 word embedding，然後搭配 BiLSTM 訓練出一套斷詞系統。而後透過斷詞出來的結果再加上 word embedding 訓練出詞性標注。 而最後最重要的 NER 也是由 BiLSTM 訓練而成，需要拿前面的 word embedding + 斷詞結果 + 詞性標注當作輸入。有了這一整套系統，我們就有基本的中文 NER 可以用了。這套斷詞系統相當精確，也有許多類別，地點、組織等都會標記出來，我們只要取用人物的部份即可。 不過人物的部份，他會連一些簡稱（張嫌、陳婦）都標記出來，所以我們這邊會做一個簡單的 filter 去過濾這些結果。 ckiptagger 的版本需求： python&gt;=3.6 tensorflow&gt;=1.13.1,=1.13.1,&lt;2 (one of them) gdown (optional, for downloading model files from google drive) 記得要先載他 train 好的 model 才可以使用，你可以用上面的 gdown 或者直接從載點下載，詳情請參照 ckiptagger。 我們這邊使用的配置如下：12ckiptagger==0.1.1tensorflow-gpu==1.15 一個簡單的範例片段：12345678910111213141516from ckiptagger import WS, POS, NERckipt_data = 'ckip' # ckip pre-training pathdoc = '重判12年又加保3億，法官怕中電前董周麗真逃亡。'ws = WS(ckipt_data)pos = POS(ckipt_data)ner = NER(ckipt_data)word_s = ws([doc], sentence_segmentation=True, segment_delimiter_set=&#123; '?', '？', '!', '！', '。', ',','，', ';', ':', '、'&#125;)word_p = pos(word_s)word_n = ner(word_s, word_p)namelist = set([e[3] for e in word_n[0] if e[2] == 'PERSON'])print(namelist) # &#123;'周麗真'&#125; 至此，一個不太精確的標記系統已經完成了，此比賽模型也已經有了一個雛型。接下來就講講如何把他接上 API，提供服務給外界使用。 服務建置 Service主辦單位提供了 Azure 雲端給我們使用，主要有用的東西除了一個 Ubuntu 可以使用外，還有 K80 的 GPU 及一個 IP。 不過原則上還是自己配的環境好用些。 flask主辦單位提供了一個簡易的 flask 模板給我們使用。裡面有強調一點，回傳的 encoding 必須為 UTF-8，只要在 app.run 前更改一下 flask 的 config 即可：1app.config['JSON_AS_ASCII'] = False API call 分作兩個部份 health check 和 inference，health check 主要在確認 service availability，而 inference 主要是負責答案的判定。 health check:123456789101112131415@app.route('/healthcheck', methods=['POST'])def healthcheck(): """ API for health check """ data = request.get_json(force=True) print(data) t = datetime.datetime.now() ts = str(int(t.utcnow().timestamp())) server_uuid = generate_server_uuid(CAPTAIN_EMAIL+ts) server_timestamp = t.strftime("%Y-%m-%d %H:%M:%S") return jsonify(&#123; 'esun_uuid': data['esun_uuid'], 'server_uuid': server_uuid, 'captain_email': CAPTAIN_EMAIL, 'server_timestamp': server_timestamp &#125;) inference:123456789101112131415161718192021222324252627282930313233343536373839answer_cache = &#123;&#125;@app.route('/inference', methods=['POST'])def inference(): """ API that return your model predictions when E.SUN calls this API """ data = request.get_json(force=True) esun_timestamp = data['esun_timestamp'] #自行取用 server_timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S") ts = str(int(datetime.datetime.now().utcnow().timestamp())) server_uuid = generate_server_uuid(CAPTAIN_EMAIL+ts) answer_template = lambda ans: jsonify(&#123; 'esun_timestamp': data['esun_timestamp'], 'server_uuid': server_uuid, 'answer': ans, 'server_timestamp': server_timestamp, 'esun_uuid': data['esun_uuid'] &#125;) if data['esun_uuid'] in cache_answer: if cache_answer[data['esun_uuid']] != None: return answer_template(cache_answer[data['esun_uuid']]) else: while cache_answer[data['esun_uuid']] == None: sleep(4) return answer_template(cache_answer[data['esun_uuid']]) else: cache_answer[data['esun_uuid']] = None try: log(data['news']) answer = predict(data['news']) log(answer) except: log('model error') raise ValueError('Model error.') cache_answer[data['esun_uuid']] = answer return answer_template(answer) 從上面的 code 可以發現，我們在 inference 做了 cache，原因是一個 inference 時間上限為五秒，逾時就會重新發 request 過來，次數上限為三次。 為了避免逾時而重複 inference，所以我們做了 cache。不過 inference 通常滿快的，一兩秒內就可以算完了。 static IPAzure 對外不開放 80 和 443 以外的 port，所以原則上把服務開在其中一個 port 即可。 那如果手上有比較好的顯卡，覺得 K80 跑得太慢，但該電腦又沒有固定 IP 的話怎麼辦呢？ 這時可以使用 ssh port forwarding 的功能，forwarding 分作兩種，正向代理和反向代理。正向代理是將伺服器端的 port forward 到我們的電腦上，所以我們可以把伺服器端的服務拿到我們客戶端的 port 來用。反過來想，今天我們是要把我們客戶端提供的服務放到伺服器上，所以用的是反向代理，假設我們把 flask 開在 8080 port 上，那只要 forward 到伺服器的 80 port 上，那外面的人只要用 http protocol 瀏覽伺服器的 IP 位置即可。 值得注意的一點是，/etc/ssh/sshd_config 裡面的 AllowTcpForwarding 必須是 yes，才可以 forward。剛改完記得要重啟 ssh server。 1systemctl restart sshd.service 然後因為 ssh 容易掉，我這邊使用 autossh 讓他自動重連就穩多了。 12autossh -M 20000 -i ~/.ssh/id_rsa -NfR :8080:localhost:8080 user@azure# foward local 8080 to remote 8080 可以看到，我將本機端的 8080 port forward 到遠端的 8080 port，因為遠端的 80 port 需要 root 權限，但有時 ssh 會關掉 root 遠端登入（只允許 console）。所以這邊可以透過 python-port-forward: 1sudo python2.7 port-forward.py 80:localhost:8080 將 8080 port 再 forward 到 80 port，我們就可以使用 azure 的 IP 了。 原則上有靜態 IP，有 ssh 的 server 都可以使用 forwading，像這次比賽基本上都是由家中 NAS 提供服務。 slack前置作業都完成後，只要把 web hook 掛給官方提供的 slack bot 即可。之後比賽他就會去戳你給的 IP address 了。 到這邊，已經可以開始拿做好的東西打一場比賽了。接下來讓我們繼續把 model 調得更好！ 基本模型 Basic ModelLogistic Regression, SVM and XGBoost前面提到的 classifier 作法相對簡單，而準確度有待加強。直接拿所有 AML 文章相似度排名取 threshold 分類還是太粗糙。 這裡我們使用 sklearn 裡面一些比較正式一點的分類器，用剛剛做出來的 bm25 + w2v feature 表示一篇文章拿來做分類。詳細教學可以參考 這篇文章。 我們嘗試了三種分類器：LogisticRegression（羅吉斯回歸），SVC （SVM 分類器）還有 XGBoost。 1234567891011121314clf = LogisticRegression(C=1.0,solver='lbfgs',multi_class='multinomial')clf.fit(xtrain_tfv, ytrain)predictions = clf.predict_proba(xvalid_tfv)clf = SVC(C=1.0, probability=True) # since we need probabilitiesclf.fit(xtrain_svd_scl, ytrain)predictions = clf.predict_proba(xvalid_svd_scl)clf = xgb.XGBClassifier(max_depth=7, n_estimators=200, colsample_bytree=0.8, subsample=0.8, nthread=10, learning_rate=0.1)clf.fit(xtrain_tfv.tocsc(), ytrain)predictions = clf.predict_proba(xvalid_tfv.tocsc()) 這裡 classifier 的準確率來到了 88% 到 90% ，而大樂透類的新聞也被準確歸類了。 BM25 + XGBoost as classifier經由測試，XGBoost 的效果是最好的，於是我們就把 classifier 換成 XGBoost。 NN model (ckip) + XGBoost + rule based as extractor (NER)另外，因為比賽要求是要有 AML 犯罪相關事實的嫌疑人，所以原先採取的把所有人名都噴出來的作法或許可以再細緻化。這裡我們將一個人名前後五個 token 的 BM25 分數加起來丟給 XGBoost 去分類，接著再丟給一開始的 rule based 來優話我們的目標人名提取器。 Neural Network在資訊檢索的課程中，教授有提到 BERT 這個神器，但我們在之前的 project 並沒有嘗試。相較於 IR Task 那種大量文本的處理，BERT 比較適合小文本的任務，這次的比賽就是一個非常好的發揮空間，所以我們在此次比賽也開始了對 BERT 的初次嘗試。 因為先前傳統機器學習方法如 BM25, TF 之類的是用 one-hot encoding 的方法，存在特徵稀疏的問題，word embedding 相應而生。他將一個詞映射到一個低維稠密的語義空間，使相似詞可以共享上下文資訊，提升泛化能力。深度學習在近幾年來快速發展，像是前面提到的 word2vector 還有後面開源的 ckip 斷詞工具都有利用到 word embedding。這類工具主要架構大多是用 unsupervised learning 訓練每一個詞的 word embedding，這其實就是在做一個特徵提取的動作，接著再確定想要的任務，例如 ckip 的斷詞或是詞性標記、NER 等，使用先前訓練出來的 embedding 作為表達式，再做一次 supervised learning 讓他更加確定需要的上下文關係，來建立最終的 Model。 根據這種模式，近幾年來發展出了像是 ELMo、OpenAI 的 GPT、Google 的 BERT 及一堆他的變形、其他像是 CMU 的 XLNet 等。訓練 word embedding 從一開始的 RNN 到 LSTM 最後到 Attention，更多原理細節可以參考 這一篇介紹。 我們在測試賽之前嘗試使用 BERT 建立一個新的 classifier，準確度有大幅的提昇。 NN model (BERT) as classifierBERT 的使用也相當容易，python 有一個集 NLP 大成的套件庫叫做 transformers，裡面不僅有 BERT， 也有 XLNet 等 model 。 詳細的實作教學可以參考 進擊的 BERT：NLP 界的巨人之力與遷移學習。 而原理可參考李宏毅教授的 BERT 的教學影片。 要下載 BERT 的 pre-training 相當容易，只要把填好 pre-training 的名稱，他跑下去發現沒有的話，就會自己去載了。 至於有哪些 pre-training，除了上網 Google 外，基本上可以來 hugface 的網站 上面找，因為此次是中文的比賽，所以我們使用了最基本款 bert-base-chinese 即可。 基本上 BERT 的使用細節都可以透過這篇 教學文 學到，裡面也有範例程式碼，學習起來算是相當的容易。 BERT 提供了四大下游任務（就是四個 supervised 的 NN Model），我們可以根據我們的需求，選用適合的任務模型來使用。關於更詳細的四大任務介紹可以參考這篇 知乎專欄 BertForSequenceClassification：下圖的 (a) 和 (b)，只差在一個 [SEP]，可以用作分類。 BertForMultipleChoice：根據問題，可以從多個選項中選擇一個最佳的答案。 BertForQuestionAnswering：下圖 (c)，用作閱讀理解，可以根據問題標出文章中的答案。 BertForTokenClassification：下圖 (d)，可以為每個 token 做分類，適用於 NER 任務等標記。 根據需求，我們使用了 BertForSequenceClassification 做了對單個篇新聞的分類（AML &amp; non-AML），但受限於 BERT 512 的 token size 限制，我們取了文章最後的 510 個 token 丟進 model 。 在 validation data 上的分類準確度從剛才的 90% 直接來到了 99% 。 一個比較基本可以用的 AML 犯罪名單提取系統已經差不多了。時間也來到了測試賽。 測試賽開始：測試賽僅僅提供測試 server 的穩定度，並沒有提供題目正確答案和分數。 進階模型 Advenced Model藉由 BERT，我們的 Model 來到了一個嶄新的境界，想必剛剛各位也有留意到，BERT 也有提供 NER 的任務訓練，而 ckip 的 NER 是用在廣泛用途的，那何不用 BERT 自己也 train 一個呢？ Make our NER根據主辦單位的標記資料，每一篇 AML 文章都有對應的人名集合。 要把資料輸進 BERT 做 NER 還需要把每個 token 做標記。這邊我們根據 IOB format，只要把目標人名用 B-PER, I-PER 標起來即可。 首先我們先用 BERT 載入 bert-base-chinese，使用他的 tokenizer 為每篇 AML 新聞做 tokenization。 接著根據幫匹配的人名標上標記，其餘的標上 O 即可。 只要寫個小小的 script 轉換完資料，接著使用 BertForTokenClassification 就可以開始愉快的 train NER 囉！ NN model (BERT) as extractor (NER)蠻出乎意料之外的一點是，可能是僅僅標記 AML 目標人物的關係，NER 出來的結果似乎就有了簡單的分類能力，可以避開一些非 AML 相關的人名。所以我們使用 BERT NER 抓出來的結果就不丟進 XGBoost 做分類過濾了。 到這裡，基本的模型已經構建完畢，這就是我們進行正式賽的 Model。 正式賽分作兩週，共八天。正式賽第一周開始：我們在這週的排名第一天在第四，之後又掉到了五和六。 Extend The DataSetReuse The IR Model第一周結束的假日，我們用之前的 IR model 將主辦單位標記的三百多篇 AML 新聞當作 query，檢索回相關新聞，並標記了一千五百篇 AML 相關新聞加入 corpus。 正式賽第二周開始：我們成功爬回了四而隔天又掉回了五，加入一千五百篇的資料似乎有一點提昇。不過 model 似乎還要再加強一下，所以我們決定嘗試其他的 Model。 Try other NN Model我們又嘗試了其他 Model，像是 XLNet, RoBERTa, Albert 等，不過效果似乎並沒有很大的提昇，不知道是不是用法錯誤（比如 XLNet 的 Mask 是 &lt;sep&gt; 而不是 [SEP]），只有 RoBERTa 在 classifier 的表現上的結果有好一些。 NN model (RoBERTa) as classifier最後，經由測試，我們將前幾天的 query 當作 validation set，RoBERTa 的準確度從 96% 上到 97%，RoBERTa 的 classifier 似乎有變好，於是我們將 classifier 換成 RoBERTa。 下圖是我們的最終架構圖： 由於主辦單位不小心把第七天的 query 送成前一天的，故第七天沒有列入計算。可能是 RoBERTa 的表現加上 1500 的標記資料生效了，最後一天我們的成績跑到了第三名。至此，整個賽程結束。因為我本身的研究領域不是 NLP，加上時間因素，能有這樣的成績已經是相當幸運了。三個禮拜衝刺也到了一段落了 :) 其他 Others除了先前的嘗試，其實我們也有想到一些增強 model 的方法，不過礙於時間關係，我們沒來得及做這些嘗試。 evoluationary computation我們在嘗試前面的 Model 時，有嘗試用演化計算來調整參數。不過後來 Model 都轉移到 NN 上，我們在傳統機器學習方法上就沒再做更多嘗試了。其實演化計算的應用很廣，或許可以應用在現在 Model 的參數微調上。 other models其實我們覺得我們 XLNet 以及其他 model 的使用可能不是很正確，所以效果才沒有上來。礙於時間因素及現有其他 model 的網路資源較為缺乏，我們沒來得及做更多嘗試。 或許存在著更棒的 model 也說不定。 improve the pre-training model拿將新聞 corpus 繼續做 pre-training 的 unsupervised learning，應該可以加強 pre-training domain specific 的能力，效果也可能因此提昇。 expand the dataNER 的部份，也可以將一千五百篇的人名做標記，如此 NER 的效果可能會提昇一些。 data augmentation跟圖片一樣，NLP 的分類也可以使用 augmentation，這似乎也是一個研究的方向：一個中文數據增強的實現。]]></content>
      <categories>
        <category>Note</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[散人]]></title>
    <url>%2F2020%2F07%2F28%2Fnobody%2F</url>
    <content type="text"><![CDATA[一年了，這邊也該動動筆了。 那就紀錄一下發生了什麼事情吧。 該從哪裡追敘呢？那就從大學畢業說起吧。 May &amp; June, 2019完成最後一學期的課，也拉了兩個好朋友參加了畢業典禮。 我的室友兼學伴（笑）也幫我拍了許多畢業照。 最後一學期的課大概是四年來修得最爽的了吧，修了 CG, CV, DL，雖然 CV 修得不甚扎實，CG 也修得水水的，但三門課的 final 都用 DL 的 colorization 做掉，感覺滿有成就感的。雖然只是把別人的 U-net 載下來加上 ResNet 而已。但整個配環境和怒 Train 的過程也是相當寶貴的經驗。 為了這三門課的 final，還配了一台新的桌機，i7 + 16G RAM + 1T SSD，配了張二手的 1080Ti，花了老爸四萬多（GPU 佔了一半錢 （這個記在帳上…） 也算是為了升研究所一次總升級吧，畢竟比起其他同學，我是一台 ASUS 筆電撐四年，也算是沒有特別花到什麼錢了。 GPU 的錢就用 AI 比賽慢慢賺回來吧（？） 記得開始怒 Train 沒多久，Tom 擔任助教的課（hhh 教授的演算法）邀請了網路黑貓來演講，我沒事的話，習慣性會去旁聽那門課，於是就這樣和黑貓大有了一面之緣。演講結束後，我還在跟同學討論說 GPU 會不會燒掉時，黑貓大聽到後還向我掛了保證儘管用 XD，因為 GPU 會自己調節降溫。 WSM 應該是我所有課程裡面收穫最多的，果然 mftsai 老師的課就是讚，兩門基礎程式設計課也是難忘。 他的課有趣，作業也很有得發揮，考試準備起來也頗有成就感，最後就是他分數也很敢給。 我大學生涯裡的唯一一次滿分就是他給的，其他兩門還有九十七及九十九，不過比起分數，更重要的是 Vim, Linux 宗教，也是他傳給我的，受益無盡。 教授可以算是在工具使用上的貴人吧，如果我有一絲一毫的 geek 氣質都得拜他所賜。不知道他最後有沒有曉得，每個禮拜陪我來旁聽的同學其實是我爸呢 XD WSM 的 final 也是最後神翻轉，第一個報告的（分數最低的那組），最後竟然會變成最高分的 XD 最後還有兩位我很感謝的教授，這三位教授應該能算是我在大學時期的三個貴人。（其實還有個隱藏版的 ccc 教授、資管系的 yuf 教授、台大電機的江教授，可惜我跟他們修的課少，那裡學到的東西也相對不多，我的研究能力也不夠強，沒辦法做出什麼東西） ck 教授帶我看到了更廣大的世界，接觸了函數式的美，給了我難得的課程助教機會，還有一些區塊鏈相關的知識。從大一就有緣份去旁聽他的課，到後來受了他很多照顧，身為導師，他也給我相當多的關心。也因為他，我才有了機會去認識資管系那邊的教授。不過沒能做出什麼東西，我還是有點遺憾的。 mtchi 教授是我兩位好友的專題老師，因為我和其他兩個同學常常一起出現的緣故，他還邀請我去他們的導生聚，還笑著說我還真像他的導生。對於我而言，受益最多的課應該就是他的 system programming 吧，算是和我的領域相關，而其實也是他的遊戲課也把我們三個朋友聯繫在一起，也才有後來的 CG Lab 三劍客。 最後與同學的回憶，大概就是那個飯局吧。大一一進去就認識的 Allen，接著和 Tom 三個人成為飯友。接著認識 mingc、meijin，大神帶了我們兩個去比賽，那是我第一次開了眼界，也是第一次見到了所謂高手境界。之後拉入 jeffu, 我們六個人組了兩隊，看大神如何以一己之力和名校選手抗衡 XD 。最後認識了轉入的 binjin，他、meijin 和我成為了 CG Lab 的的三劍客。六個和我大學生活密切相關的同學，和我爸，我們一起吃了飯，為這段四年的緣份點上了一個不錯的段落。 喔對了，可能是卷哥提早畢業，然後卷二也沒修啥課，最後一學期的成績就這樣不小心被我拿了第一 XD July &amp; August離開了原本的學校，宿舍南遷，我在新宿舍待了兩個禮拜才去 Lab。這兩個禮拜在整理新的資料，主要是要延續 WSM 的 final，一個 NLP 的 IR 比賽，是關於新聞立場的檢索比賽。兩個禮拜的瘋狂下資料後，我來到了 plaslab，認識了新夥伴 rnic，以及 plas 其他的成員。沒待多久，我就前往台北參與開源人的盛事，COSCUP，rnic 還是 rust 議程的其中一位講者 XD。結束兩天的朝聖後，我就接著為期兩個禮拜的 flolac 了，聽了 yuf 教授和江教授的課，還認識了一位學弟 Nemo（也是大神一個 XD）。 回到學校後，開始去認識新環境的人們。和之前相比，這裡的高中同學多了許多，剛好四個和我同校，而三個在隔壁。發現其實大家大部分到最後都走到了資訊這一塊。隔壁動機系的同學之後要做 CV，資工系的要 DL，而化學系則是繼續他的研究（我有問是哪方面的，不過到現在也是忘了 55），同校的電機系同學是原生種，直接讀五年碩，目前也是做 DL model 的優化，而同為資工系的同學進的實驗室在做演算法，以後應該也是會做有關 DL 的方向。我們在 KFC 吃過了一餐，不過之後好像也沒什麼在聯絡了（ 也遇到了一個國中小同學，目前是在做圖學相關的方向，不過可能是興趣的方向不同，之後上課也沒啥遇過了。 September to January學期初，跟著 rnic 一起修課，感覺課都滿硬的，修了計架、數值軟體、平行運算和正規語言。 計架和正規語言算是比較理論的課，而平行和數值算是比較實作的課程。 計架算是計組的延伸，除了回顧一些先前的知識，也介紹了滿多其他的東西。期末 paper reading 的部份，滿多組別都在介紹 FPGA 那些 AI 晶片，我們讀到的是一篇關於 Data Flow 的優化方式，也蠻有趣的。 正規語言在大學也有修過，不過這門課多了滿多證明的，修完了感覺自己還是不太會寫，正規還是很不扎實 XD。 數值軟體讓我真正接觸到了 python binding 的寫法還有一些會影響 performance 的小細節。我們使用 pybind11 來幫助 python 調用 cpp11 的 code。最後期末 project 我選了 SVM 當主題，不過沒時間也寫不出來，也就把這門課 drop 掉了（（ 我在平行程式學了許多平行化的方法，像是大學已經接觸過的 threading，還有 OpenMP、OpenMPI、OpenCL 還有 CUDA。不過沒有接觸到 SIMD 感覺有點可惜。最後我們期末寫了關於 huffman encoding 和 decoding 的平行化。隔壁組則是寫了太鼓達人的 RL 平行化 XD 不過平行的遺憾很巧合地被補起來了。十月份的時候，剛好看到黑貓大大在元智大學有一場 Halide 的分享，那門課先教了我們 ARM 上 SIMD 的寫法，然後用自己的手機上運行 gemm。之後教了 Halide，發現他 SIMD, threading，tiling 什麼的全部幫我們做掉了，TVM 據說也是受 Halide 啟發而發展出來的，一套 Halide 打天下，感覺也是相當有趣的研究方向。最後在 lab 實作和回答問題，我和 rnic 還得到了兩塊板子，黑貓大大人實在太好了 XDD 兩週後，在學校餐廳還和他巧遇了，留下了一張合影 :) TBC February to August遇到高中同寢的學長。 資訊檢索比賽落幕。 TBC]]></content>
      <categories>
        <category>Memoir</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[COSCUP'19]]></title>
    <url>%2F2019%2F08%2F14%2Fcoscup19%2F</url>
    <content type="text"><![CDATA[先來排個議程，或許可以把心得/筆記直接寫在本文。 排的結果依舊是... 起手吐槽依舊是滿滿 PL 加一點 Block Chain… 說好的 AI 呢？ COSCUP DAY1入場 開幕 &amp; LINE Open UpIB101 08:30 - 9:50 漢語 200 speaker, 2k participants. Haskell Line API 等你開源 //我發現 Hackage 上已經有了（ line-simple-beacon line-liff-starter line-things-starter, about IoT line Armeria, help you to build line service quickly 給 Web 工程師的 Rust 上手指南IB301 10:00 - 10:20 漢語 Rust 吉祥物 — 螃蟹。picked up by Mozilla.想填補系統級編程空白而發展 Rust — fast, safe, concurrent。 facebook libra - about currency, safty, transaction, wrote in Rust. 議員(Denver Riggleman): Why Rust? Yew framewrok (rs -&gt; web asm) iter callback like Ruby type signature like Python mcaro 寫 HTML — html!{...} side effect function with ! last expression in function as return value, like Ruby 認識零知識證明IB502 10:30 - 10:55 漢語 What is ZKPs 以阿里巴巴為例。 zk-SNARK zk - zero-knowledge S - Succinct N - Non-Interactive (consider network traffic) AR - Arguments (should be large to prevet bf attack) K - Knowledge Alice has P(x)Bob has secret point sAlice cal P(s) for Bob The S: Homomorphic Hidings for most x, E(x) is hard to find x different outputs for differnent inputs E(x + y) can be computed for E(x) and E(y) if x + y = 7A publishes E(x), E(y)B computes E(x + y) by E(x) and E(y)B computes if E(x + y) == E(7) KCA 規範對方的行為 alpha-pairA have (a, b), (a, alpha * a)B have (a’, b’) =&gt; (gama * a’, gama * b’ = gama * alpha * a = alpha * a’) 補充 QAD 問題轉換及簡化 The N: CRS - public place for A to place things SNARKs pros: proof size, verification time STARKs pros: proof time cons: proof size Bulletproofs（門羅幣使用） cons: proof time, verification time EWASM VM - 次世代的 Ethereum Virtual MachineIB502 11:30 - 11:55 漢語 EVM recap stack-based 256 bit stack items high level instructions SSTORE, SLOAD SHA3 CALL, CREATE contract too far away from actual machine architecture less language support (Vyper, Solidity) How about wasm (web assembly)? has locals(~= reg or mem) only access top 3 items v.s. EVM’s 16 (property here!!) support 32/64 bits No high level instructions ewasm ewasm is subset of wasm not support floating point number LIMITED imports and exports (wasm section) inject byecode metering and has runtime metering Ethereum Environment Interface 1ewasm module &lt;= EEI =&gt; blockchain call some function by outer runtime environment ewasm 透過 EEI 將一些 operation 交給外部的人 system contract compiled into wasm bytecode examples Byzantium precompiles sha256, rpiemd160 Sentinel (verification and metering) Sentinel contract ewasm bytecode =&gt; Sentinel =&gt; deployed on chain before contract deployment reject non-ewasm bytecode (e.g. floating point) insert metering statements EVM-C 開一個 EVM spec, 不同的 ethereum client 實作共用一個 Wasm VM C =&gt; C langauge API wasm engine 12345678910111213141516171819 ewasm bytecode | v (parse) | v ewasm module | v (validate) | v validated ewasm module | v(instantiate) e.g. aloc mem | v deploy EVM issue storage model ewasm = EVM 1.0 mirrored in wasm storage model is not compatible with rent performance ewasm(64) BN128mul not better than EVMone(256) becuase bit operation solution: precompile price metering basic block count super block upper bound speaker is from buidl.secondstate.io 關於生命週期的一點事兒 (miss)IB301 11:30 - 11:50 漢語 Serverless Web Service in Rust (miss)IB301 11:50 - 12:30 漢語 『基礎建設』 建置 Tor 的匿名 .onion 網站，並使用 Kubernetes 架構 (miss)E2-102 12:05 - 12:35 漢語 Functional, Declarative and Modular System Environment with Nix and NixOSIB503 13:20 - 13:50 漢語 GNU related Project GNU Guix 九月份 functional thursday 會有 Nix 相關主題。 speaker(@zetavg) touched the nixos from 35th chaos communication congress presentation Software Deployment Problems The purely functional software deployment model by Nix author Nix: Nix is package manager1#purelyFunctional #immutable #declartive #lazy #garbageCollator Nix Store: pkg should not depend on global system stuffruby &lt;- /usr/lib/libssl.so (x)ruby &lt;- nix-libssl-pkg (v) Nix Lang: produce derivation take package as variable in the Nix Lang there exists dependencies between the variables Nix OS: pkg, kernel, config… are built by Nixwhole system in the Nix Store Nix Env: can switch generations after installation stages Nix Shell: a nix tool for Developer More: cachix: Nix binary cache(precompile binary) Hydra: nix build farm NixOps: declaratively deploy infrastructures 9/5 f4 at Mozilla 信義區辦公室Nix Pills https://nixos.org/nixos/nix-pills Build a Minimalist Partially C99-compliant Compiler for Real-world Targets (miss)IB201 13:20 - 13:45 漢語 Cuju - 虛擬機容錯功能實作IB201 13:50 - 14:35 漢語 Too hard to take note. project page 效能等級和 VM Ware 差不多？！ 用剖析表達文法 PEG 實作一套程式語言 parserIB301 14:30 - 15:10 漢語 understanding computation: from simple machines to impossible programs pl parser, regex parser with treetop, which is a PEG parser PEG, 2004, Bryan Ford - parsing Expression Grammars: A Recognition-Based Syntatic Foundation a replacement to chomsky language, by removing the ambiguity in grammer the ambiguity is useful in modeling natural language, but not in precise and unambiguous programming language basic rule: replace | in CFG with / operators &quot;&quot; [] . (e1 e2 ..) e? e+ e* &amp;e !e e1 e2 e1/e2 note the priority, different from CFG PEG dangling else“if” COND “then” S1 “else” S2 / “if” COND “then” S1 match the else first will solve the problem (CFG can’t) PEG is equivalent to Top Down programming language (TDPL) PEG is not a lang but a parse impl spec. PEG new, powerful than CFG, fast to parse small lang 用 Pandoc 撰寫學術文章IB503 15:30 - 16:00 漢語 是中文流利的外國人呢。清大語言所的博士候選人（學過 Python, Haskell（？！ 文書處理器 Latex 上手 易 難 排版 易跑 專門 文件 短 長 模式 編寫編排 寫排分工 why open source? open format easy to export, share fee, no license customization 文科:只有肥宅才會用 LATEX 吧！（戰起來！！沒，其實本貓也是文組的（ 以 markdown 取代 latex markdown is not program, formated text can be compiled source is human readable markdown dialect: pandoc markdown commonmark github-flavoured markdown what is PANDOC? 轉換神器 柏克萊哲學系教授 john macfalane 所創 support latex, markdown pdf docx html reveal.js support ppt by markdown YAML metadata blocks參考文獻可使用 bib(la)texcorss-referencinginline latex biblography with pandoc (by pandoc-citeproc filter)cross-reference (by pandoc-crossref filter) pros: open source raw text git version control collaboration bugless cons: learning time consuming need latex sometimes command line interface https://pandoc.org/getting-started.htmlhttps://pandocorg/MANUAL.html 17 直播從 0 到 1 之狼人殺 &amp; 5 years Rust &amp; 回顧 (miss)IB101 16:10 - 16:40 漢語 COSCUP DAY2因為昨天施工挖斷電纜，所以換場地。 本日摘要 &amp; 自己玩量子電腦程式IB101(TR313) 09:00 - 09:50 漢語 講者是第一屆總召（Google AI Quantum）。現行計算稱為古典計算(classical computing)。 量子程式語言：IBM Qasm, M$ Qsharp 量子電腦應用場景： 量子模擬 （氮固化，肥料製造用了世界 2% 電力，研究微生物為何消耗極少能量產生。） 優化 求函數極低點，或許可用於計算能量消耗。 質因數分解 “How to factor 2048 bits rsa integers in 8 hours using 2 million noisy Qubits” 量子電腦破解 RSA 加密（古典電腦需要宇宙時間） 電子電腦需要 10mK（常溫 300K）環境下運作，所以需要放在冰箱。 現在發展的現況為幾十 Qbits。Cirq — Google Python framwork for Quantum computation N Gate (Not Gate)H Gate 薛丁格的貓 如果前面放進一個 H Gate = (00, 11) the quantum parity problemclassical -&gt; quantumO(N) -&gt; O(1)輸入輸出前各 apply 一排 H gate，最後觀察最後結果。 transportation of 1 quantum bitqbit A 由於觀測後會塌陷，所以要拿 qbit B 之前，先將 qbit C 與 qbit B 糾纏，然後用 B 與 A 糾纏後，將其結果拿給 C 運算即可得到 A 當初的態。 Q: 能解什麼問題？對目前 framwork 的看法，需不需要開發新語言？A: 解的問題還在發展，美國正在培養相關人才，需要大量相關人才。量子運算與古典運算是互補的。 重點是那個 H bit，模擬薛丁格的貓，他是一切算法的起手式。 懶惰鬼的函數式爬蟲IB101(TR313) 10:00 - 10:50 漢語 functional/Haskell blockchain/Tezos general json crawler 第三方服務共同特色 大多提供 JSON API Tezos 三大特色： liquid proof-of-stack動態決定驗證者/區塊創建者，由 token 持有者共同維護 formal verification保證系統安全性 on chain government由投票機制更改 protocol（第 999 和 2019 block 的 JSON 可能長得不一樣） Backing SodaA Haskell crawler for Tezos 講者：有實際寫過 DSL 或知道 DSL 的請舉手我：寫 DSL（compiler or interpreter）太難了吧？！ 我只有寫過 GPL（ Haskell 起手式：定義好資料結構Formal program synthesis: deriving(Show, Read, Eq, …) 平行化：123main = a `par` b `pseq` print (a + b) where a = fib 42 b = fac 42 crawler 存原始檔案 不要相信第三方 減少第三方壓力 後續批次處理 123456789data TzBlock = TB &#123; level :: Int &#125;class Crawler a where weed :: a nextStep :: a -&gt; ainstance Crawler TzBlock where seed = TB 0 nextStep tb = TB &#123; level = level tb + 1 &#125; 分析：JSON 對應 SQL 的 datatype 資料庫選擇： Haskell property type strong and ADT easy to provide universal data store interface lib haskell-persistent haskell-groundhog General Database 可選擇 放棄特有功能：e.g. postgres array tyepSpecific Database 比較好的效率 加強 Android 隱私的工具和技巧 (miss)IB201(TR309) 10:50 - 11:20 漢語 &gt; 跑去吃飯，結果遇到在台大讀書的同學啊啊啊啊啊啊Instruction Scheduling in LLVMIB306(TR412-2) 11:40 - 12:25 漢語 instro to instruction scheduling LLVM scheduler pipeline modeling scheduler customization instruction scheduling as a means of optimization 1234load x5 x8 @a // 3 cycle timeadd x5 x5 x5 // 4th cycle timeload x6 x8 @bmul x5 x5 x6 build dependency graph and sort from root, acc time length from first instscheduling with reverse order (from large acc number to smallest) instruction scheduling occuring on:12345678910111213141516instruction selection (DAG) | | scheduleDAGSDNodes v M-I | | scheduleDAGMILive v registor allocation | | schedulePOSTRATDList v M-I | v ... Data Dependency Graph output depedency (if inst depend on same reg, they can not swap) anti dependency boundary not participate scheduling target description as a language to write pipeline Customize Scheduling for Target define scheduling policy implement overrideSchedPolicy define scheduling strategy derive MachineSchedStrategy (GenericScheduler) add DAG mutations implement ScheduleDAGMutation::apply reference: Engineering a Compiler（阿阿阿阿 這本我有啊） LLVM Developers’ Meeting: “writing Great Machine Schedulers” 從 C++11 規格和 Template Meta-Programming 的角度欣賞 Boost 對 atomic 和 memory order 的支援E2-102(TR510) 12:40 - 13:10 漢語 what is memory order recorder out-of-order compiler 會做 scheduling，所以 order 和 source code 可能會不一樣。C++11 支援 memory order 可以給予開發者控制 order 的餘地。 synchronization operations在不同 thread 之間同步 atomic operation 講者聲音有點小聲，然後講題於我有點陌生（ 在 21 世紀做自動微分？你需要 Zygote.jl！IB501(TR413-1) 13:10 - 14:00 漢語 Wengert list a list of expression/instruction transform the expression with derivative definintion how automatic differentiation work get the Wengert List of the expression transform each instruction in the Wengert list apply chain rule forward mode (適合 outputs &gt;&gt; inputs) dual numberreverse mode (適合 inputs &gt;&gt; outputs) (mostly DL situation) tracker 野生的 Meta Programming 出現了 (miss)IB301(TR310-1) 14:20 - 15:00 漢語 Julia 語言設計與 JIT 編譯器IB501(TR413-1) 14:10 - 15:00 漢語 outline: type system mulitple dispatch generic program meta programming relection and introspection JIT compiler 12345678910111213 Any ^ | subtype | |instance &lt;-- is-a --+--typeof--&gt; Datatype | subtype | v Union &#123;&#125; type system dynamic, similar to symbolic programming,but can get staic component by some signature set-theoretic type mulitple dispatch 非獨有特色，其他語言也有 like overloading in Cpp generic programming parametric types and parametric method Similar to multiple dispatch with parametric polymorphism All types are first-class: can be dispatched and declared meta programming macro generated function (julia 獨有) 123456789101112@generated function foo(x) Core.println(x) # x as a type return :(x * x) # but return as a value(?)end&gt; foo(5)Int6425&gt; foo(&quot;5&quot;)String&quot;55&quot; Function(name) &lt;&gt; Method(type signature, related to impl)so, there exist function table and method table function =&gt; generic function consisted of many methods JIT =&gt; lookup compiled method (method cache),if not exists, it will do specialize, compilation meta programming interface AST access modify Julia IR access modify LLVM IR access modify Machine code access modify(indirect) julia 是 hackable 的 compiler，可以抽換掉一些中間的 compilation procedure，跟上次 flolac’18 講的 racket 黑魔法有點像。 presentation High-Level GPU Programming with JuliaIB501(TR413-1) 15:10 - 16:00 漢語 for CUDA becuase the support for AMD is not enough GPU for graphic drawing utilize the parallel structure lots of threads running at the same time for GPU programming, most PL still inline cuda C why julia high-lv PL with low-lv performance provide first class array impl good compiler design pkgs: CUDAnative.jl CUDAdrv.jl CuArrays.jl GPUArrays.jl lighting talk &amp; closeIB101(TR313) 16:05 - 17:05 終於見識到本體了，真的很歡樂（]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>coscup</tag>
        <tag>opensource</tag>
        <tag>conference</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我所理解的 continuation]]></title>
    <url>%2F2019%2F08%2F10%2Fcontinuation%2F</url>
    <content type="text"><![CDATA[對，就是那個 continuation。 About Scheme學校 scheme 學了大半學期，continuation 這個詞估計同學連聽都沒聽過。 說到底我們學 scheme 也就是為了寫那個 eval/apply (mini scheme) 罷了，頂多還有 oop 那個 vtable 而已（就是實作那個傳統 oo 的 message passing）。 用 scheme 寫 compiler 什麼的根本是夢想（艸當初如果學的是 yscheme 的 p523(p423) 該有多好（反正現在入坑還來得及（？ 總結一下目前為止，除了老師的教材，我學習過的 scheme 資源好了。 SICP Yet Another Scheme Tutorial The Scheme Programming Language 其中在學校老師推薦的閱讀是 SICP，我讀完第一章就讀不下去了。後來看到 yast，就先跳過去讀，第一次看到 continuation 就是在這裡，還有 promise 之類的東西，才了解到原來 scheme 除了 S-expression 外，還有這麼多有趣的特性。 不過讀 yast 跳過了蠻多 macro 的部份，因為有許多內容是基於實作 (MIT Scheme) 的。後來我就去寫我的 scheme interpreter in C， 雖然是個玩具，不過也玩了很久。 目前因為 Lab 同學介紹，我得知了 yscheme，但在研究時發現自己對 syntax 還是不太熟，所以又找了 tspl ，準備詳細地再學一次。 目前對於 Scheme 的計畫是 tspl &gt; yscheme &gt; SICP &gt; The Little Schemer（沒有官方版本，只有找到筆記）。不過要完成大概需要很久吧（ 此外，我來說一下我接觸過的 lisp 實作吧。 scheme: Guile 出自 GNU ，強調其腳本結合性，可以寫 C/Cpp 去擴展它，編譯器前端還支持 JS, elisp, Lua。 Racket 又稱 plt-scheme, DrScheme，其底下有一堆小語言，flolac’18 有介紹，我寫作業用的 impl。 BiwaScheme JS 寫的，當初學校教學用的是這個的 REPL。 GNU/MIT-scheme yast 用的就是這個。 Chez Scheme Petite 是他的免費版本。此 impl 聽說很快，可以看看大神介紹。 CHICKEN Scheme 這我聽很久了，但一直沒去了解它（ common lisp: CLISP GNU 的 Common Lisp 的實作，Common Lisp 和 Scheme 為 Lisp 兩大流派，彼此影響。 others: elisp Emacs Lisp，神之編輯器的內建語言，神的語言果然不能太平凡啊。 Clojure 跑在 JVM 上的 lisp 方言。 About evaluation要理解 continuation，我們必須先了解 scheme 的 eval/apply。continuation 和 evaluation strategy 是習習相關的。 application (procedure arg ...) 假設現在有個簡單的 application: (+ 1 2)，interpreter 要去解釋他： eval + symbol，find the procedure bind to it. eval 1 literal，convert it to number instance eval 2 literal，convert it to number instance apply procedure that bind to + to 1 and 2 return 3 複雜一點的例子 (cons (+ 1 2) (list 3))： eval cons, find the procedure that bind to it eval (+ 1 2) eval + symbol，find the procedure bind to it. eval 1 literal，convert it to number instance eval 2 literal，convert it to number instance apply procedure that bind to + to 1 and 2 return 3 eval (list 3) eval list, find the procedure(list constructor) bind to it eval 3 literal, convert it to number instance return (3 . nil) apply cons on 3 and 3 return (3 . (3 . nil)) special form - if (if test-expr then-expr)(if test-expr then-expr else-expr) 叫做 special form 的原因是因為它的 evaluation strategy 和 application 不同，凡是 special form 的 keyword 都有一套屬於自己的 evaluation strategy。 舉個例子，如果把 if 實作成 application 的話，每個參數都要被 eval。考慮此情況：(if #t (+ 1 2) (1 2))。 在 application 中 (1 2) 不能被 eval，因為 1 並不是一個 procedure，他不能 apply 到 2 上。這會讓 interpreter 拋出一個 exception 來警告你。但實際上 interpreter 卻沒有。為什麼呢？ 因為 if 是 special form，他只會 eval 關心的部份，剩下的部份他不進行 eval，所以不噴 exception。所以對於 if 的 evaluation 是： eval if, use the if special form evaluation strategy eval #t literal, convert it to boolean value because the test-expr is true, we select then-expr to eval eval (+ 1 2) eval + symbol，find the procedure bind to it. eval 1 literal，convert it to number instance eval 2 literal，convert it to number instance apply procedure that bind to + to 1 and 2 return 3 但是如果是 (if #f (+ 1 2) (1 2))，就會噴 exception 了。下面例子會用到 cond，他跟 if 很像，這邊就不再贅述。 special form - lambda (lambda (arg-id ...) body ...+)(lambda rest-id body ...+)(lambda (arg-id ...+ . rest-id) body ...+) lambda 此 special form 用於構造一個 procedure，一個 procedure 包含 arguments 和 procedure body。 對於 (lambda (x) (+ x 1))： eval lambda, construct a lambda procedure take arg list as procedure arguments take body expressions as procedure body return the constructed procedure 而當我們 apply 這個 procedure 為 ((lambda (x) (+ x 1)) 3) 時： eval (lambda (x) (+ x 1)) eval lambda, construct a lambda procedure take arg list as procedure arguments take body expressions as procedure body return the constructed procedure eval 3 literal, convert it to number instance apply procedure on 3 bind 3 to x, extend the binding to environment eval (+ x 1) eval + symbol，find the procedure bind to it eval x symbol, lookup the value(3) bind to it eval 1 literal, convert it to number instance apply procedure that bind to + to 3(x) and 1 return 4 special form - define (define id expr)(define (head arg ...) body ...+)(define (head arg ... . rest-id) body ...+) define 可以用來綁定變數，他也提供了 short form 來定義函數。 舉個例子，(define x (+ 1 2 3))： eval define take x as binding symbol eval (+ 1 2) as binding value eval + symbol，find the procedure bind to it. eval 1 literal，convert it to number instance eval 2 literal，convert it to number instance apply procedure that bind to + to 1 and 2 return 3 bind 3 to x, extend the binding to environment 至於他的 short form 就是 macro 變換： 12345(define (head arg ...) body ...+);=&gt; (define head (lambda (arg ...) body ...+))(define (head arg ... . rest-id) body ...+);=&gt; (define head (lambda (arg ... . rest-id) body ...+)) special form - let (let ([id expr] ...) body ...+)(let proc-id ([arg-id init-expr] ...) body ...+) let 則可以寫成一種 lambda + application 的 macro 變換。 比如 (let [(x 3) (y 4)] (+ x y)) 會被轉成 ((lambda (x y) (+ x y)) 3 4)而像上面的例子 ((lambda (x) (+ x 1)) 3) 則可以寫作 (let [(x 3)] (+ x 1)) 由於 let 都會被轉成 lambda + application，所以他的 evaluation strategy 就是先做 macro 轉換，再加上 lambda, application。在此不再贅述。 About continuation前面廢話那麼多，終於要來講講 continuation 了。我記得當初我在跟教授講我在看 continuation 時，他說可以去看看 Kent 的論文（ Kent 就是寫 tspl 和 Chez Scheme compiler 的那位 continuation 在編譯器上應用似乎比較多，CPS 和 SSA 似乎有某種關係，我覺得和 currying 也有，不過我還沒有看到那（這邊大概只會對 call/cc 做探討，畢竟要讀懂一段 call/cc 的 scheme 我不知打了多少次結。 what is continuation?continuation 代表在 evaluation 過程中的一個點，你可以在那點代入新值，重啟計算。 在方才長長的 evaluation list 中，只要有 eval 的地方就可以捕捉他的 continuation，紀錄下該 eval 的位置，下次直接利用捕捉到的 continuation, 從剛剛那個位置代成新的值，重新 eval 出另一個結果。 123456789 ; +-- continuation, the k(... ; v (call/cc (lambda (k) first-time-eval-val));&lt;-+ 1. the (call/cc ...) ; | re-evaled as restart-val ...) ;-----+- 2. get the re-eval-val of | ; | whole expr contains call/cc |(... ...) ; | | ; v |(k restart-val) ;-- 0. when apply the k expr ---+ continuation 在 scheme 中是頭等公民 (first-class)，屬於一種資料型態，像 function 一樣可以被傳來傳去的。call/cc 是捕捉 continuation 的一個 procedure，全名是 call-with-current-continuation。 call/cc with application現在我們看個 lambda 的例子：(lambda (x) (* 2 x))，我們感興趣的地方是那個 x，我們希望之後計算可以從 x 帶入新值，再次進行計算。那就來捕捉他的 continuation 吧。 上述例子使用 lambda 只是為了說明，我們還是需要一個實際的 application 來做 evaluation。 12(define x 4)(* 2 (call/cc (lambda (k) x))) ;=&gt; 8 可以看到 call/cc 需要一個單參數的 lambda 作為參數，其中那個 k 就是 continuation 了。我們在上例沒有把 k 存起來，而且在第一次 evaluation 中，我們照舊傳了 x 回去給 (lambda (e) (* 2 e)) 這個 procedure。 現在試著將 continuation 帶出來。 1234567891011(define kon #f)(define x 2)(* 2 (call/cc (lambda (k) (set! kon k) x ;=&gt; x is 2, it's the value that first time eval returned ))) ;=&gt; 4kon ;=&gt; #&lt;system continuation&gt;(kon 4) ;=&gt; 8, use 4 replace the (call/cc ...) segment in previous evaluation(kon 8) ;=&gt; 16, use 8 replace the (call/cc ...) segment in previous evaluation 可以觀察到，我們用 set! 將 x 的位置用 continuation 記錄下來，並帶入新值。在使用 call/cc 時，就把感興趣的點用 call/cc 的 lambda 參數的 procedure body 包起來就好了，而該點在第一次做 evaluation 時的傳回值，也是由 procedure body 這個 expression eval 出來的結果而定。該點的值可以在其後重新用 continuation 以不同的值帶入。 那對於 call/cc 首次 evaluation 回傳的 value 能不能直接是那個 continuation 呢？當然可以。我們在這裡使用一個 id function: (lambda (x) x)。 1((lambda (x) x) (call/cc (lambda (k) k))) ;=&gt; #&lt;system continuation&gt; 前面說到，可以 eval 的地方，就可以 call/cc，那在 application 裡，我們已經試過 arguments 的位置了。那 procedure 的位置呢？ 1((call/cc (lambda (k) k)) (lambda (x) "hello")) ;=&gt; "hello" 看得出來，做 procedure eval 時，我們得到的 procedure 是該位置的 continuation，而那個 continuation 被 apply 到 (lambda (x) &quot;hello&quot;) 上。所以 call/cc 的部份被替換為 (lambda (x) &quot;hello&quot;)，所以我們得到：1((lambda (x) "hello") (lambda (x) "hello")) ;=&gt; "hello" call/cc with special formdefine12345(define x (call/cc (lambda (k) k)))x ;=&gt; #&lt;system continuation&gt;(x 4)x ;=&gt; 4 看懂發生什麼事了嗎？第一次的 evaluation 把 continuation 綁到 x 上。而 call continuation 時，將 call/cc 換成 4 重新傳給 define，x 被重新綁定為 4。注意一點，(define x ...) 中，call/cc 並不能擺在 x 的位置，因為那個地方不做 evaluation。 lambda我們剛剛把 continuation 帶出 call/cc 外呼叫，那在 call/cc 內呼叫會有什麼效果呢？參考以下 tspl 中的例子： 123456789(define product (lambda (ls) (call/cc (lambda (break) (let f ([ls ls]) (cond [(null? ls) 1] [(= (car ls) 0) (break 0)] [else (print (car ls) (f (cdr ls)))])))))) 他定義了一個 product，將整條 list 乘起來。他在 product 的 lambda 回傳 body 用一個 call/cc 包起來，捕捉那點 continuation。然後在其中定義一個 named let 來做 recursion，遇到 0 時，直接返回 0 到外層的 continuation。省略回傳，做乘法的部份。 我們看一下，如果不用 break ，也就是正常的 product 的結果。 12345678910;; product.ss(define normal-product (lambda (ls) (call/cc (lambda (break) (let f ([ls ls]) (cond [(null? ls) 1] [(= (car ls) 0) 0] [else (* (car ls) (f (cdr ls)))])))))) 12345678910111213(normal-product (5 4 0 2))|(call/cc ...)&gt;(f (5 4 0 2))&gt;(* 5 (f (4 0 2)))| |(f (4 0 2))| &gt;(* 4 (f (0 2)))| | |(f (0 2))| | &gt;0| &gt;(* 4 0) ; do multiplication| &gt;0&gt;(* 5 0) ; do multiplication&gt;00 如果是原本使用 (break 0) 的話：12345678910;; product.ss(define product (lambda (ls) (call/cc (lambda (break) (let f ([ls ls]) (cond [(null? ls) 1] [(= (car ls) 0) (break 0)] [else (print (car ls) (f (cdr ls)))])))))) 1234567891011(product (5 4 0 2))|(call/cc ...)&gt;(f (5 4 0 2))&gt;(* 5 (f (4 0 2)))| |(f (4 0 2))| &gt;(* 4 (f (0 2)))| | |(f (0 2))| | &gt;(break 0) -+| |&gt;0 &lt;------------------+0 真的會這樣嗎？把 * 重新定義成以下這個具有 side-effect 的 * 來測試看看。 12345;; mul.ss(define mul *)(define (* a b) (let [(v (mul a b))] (printf "~A * ~A = ~A~%" a b v) v)) 用 petite repl 測試一下： 12345678(load "mul.ss")(load "product.ss")(normal-product '(5 4 0 2));; 4 * 0 = 0;; 5 * 0 = 0;=&gt; 0(product '(5 4 0 2));=&gt; 0 let而在 let 中會有什麼效果呢？大概是有點 define + application 的味道吧。 12(let ([x (call/cc (lambda (k) k))]) (x (lambda (ignore) "hi"))) ;=&gt; "hi" 另一個可以 call/cc 的地方就是 body-expr 的地方了，不過效果大概就像是 lambda 的 body-expr，因為 let 的 body 就是轉成 lambda 的 body。 至此，call/cc 可以放的地方就差不多說明過了，其餘 special form 的概念也就差不多一樣了。 Examples來看看其他 continuation 的例子。 light-weight process在 tspl 中提到，continuation 可用於 multi-tasking，以下是書裡面的例子： 1234567891011121314151617181920212223242526(define lwp-list '())(define lwp (lambda (thunk) (set! lwp-list (append lwp-list (list thunk)))))(define start (lambda () (let ([p (car lwp-list)]) (set! lwp-list (cdr lwp-list)) (p))))(define pause (lambda () (call/cc (lambda (k) (lwp (lambda () (k #f))) (start)))))(lwp (lambda () (let f () (pause) (display "h") (f))))(lwp (lambda () (let f () (pause) (display "i") (f))))(lwp (lambda () (let f () (pause) (newline) (f))))(start);=&gt; hi;=&gt; hi;=&gt; hi;=&gt; hi 來 trace 一下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172;=&gt; lwp-list &lt;display h&gt; &lt;display i&gt; &lt;newline&gt;(start)| |(set! lwp-list (cdr lwp-list))| |(p)| &gt;((lambda () (let f () (pause) (display &quot;h&quot;) (f))))| &gt;(let f () (pause) (display &quot;h&quot;) (f))| | |(pause)| | &gt;(call/cc ...) # continuation1 here| | | |(lwp (lambda () (k #f)))| | | | ;=&gt; &lt;display i&gt; &lt;newline&gt; &lt;k of h&gt;| | | |(start) | +-----------+ | v... (start)... | |(set! lwp-list (cdr lwp-list))... | |(p)... | &gt;((lambda () (let f () (pause) (display &quot;h&quot;) (f))))... | &gt;(let f () (pause) (display &quot;h&quot;) (f))... | | |(pause)... | | &gt;(call/cc ...) # continuation2 here... | | | |(lwp (lambda () (k #f)))... | | | | ;=&gt; &lt;newline&gt; &lt;k of h&gt; &lt;k of i&gt;... | | | |(start) | +---------------+ | v... (start)... | |(set! lwp-list (cdr lwp-list))... | |(p)... | &gt;((lambda () (let f () (pause) (display &quot;h&quot;) (f))))... | &gt;(let f () (pause) (display &quot;h&quot;) (f))... | | |(pause)... | | &gt;(call/cc ...) # continuation3 here... | | | |(lwp (lambda () (k #f)))... | | | | ;=&gt; &lt;k of h&gt; &lt;k of i&gt; &lt;k of \n&gt;... | | | |(start) | +---------------+ | v... (start)... | |(set! lwp-list (cdr lwp-list))... | |(p)... | &gt;(continuation of display h)... | | |(display &quot;h&quot;)... | | | (f) in let-expr ; recursive call... | | | (pause)... | | | | (append continuation to lwp-list)... | | | | (start) | +--------------------+ | v... continuation of i... (display &quot;i&quot;)... (pause)... ... (append continuation of i)... ... (start) | +------+ | v... continuation of newline... (newline)... (pause)... ... (append continuation of \n)... ... (start)... inf looping 抽象點來看，task 大概可以分成兩個部份，pause 前和後。每次遇到 pause 時，就會把 continuation 保存起來，然後 switch task，然後每個 task 跑過一遍，就會回來 pause 這個位置，pause 會被 #f 取代掉，接著 display，do named let recursive call，接著重新從開始跑到 pause，reserve continuation, switch task… inf looping… Yin-Yang Puzzle陰陽謎題 (Yin-Yang Puzzle) 據說是 David Madore 在 1999 年時，試圖去輸出的一個序列。用他發明的語言 Unlambda（沒有 lambda operation 的 lambda calculas 實作，當時是用 scheme 寫的），他一開始用了 600 個字元，後來為他的語言加上 call/cc 機制後，程序長度縮短到 12 個字元。ref 後來下面這個版本便是他由 Unlambda 轉成 scheme 的版本。 12345678910111213141516(let* ((yin ((lambda (foo) (newline) foo) (call/cc (lambda (bar) bar)))) (yang ((lambda (foo) (write-char #\*) foo) (call/cc (lambda (bar) bar))))) (yin yang));=&gt;;=&gt; *;=&gt; **;=&gt; ***;=&gt; ****;=&gt; *****;=&gt; ...;; 有的版本會用 (display '@) (display '*) 取代;=&gt; @*@**@***@****@*****@******@*******@********@*********@ ... trace 上面這段：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960let* ;; k0@yin, k0@yang yin = k0@yin ;=&gt; @ yang = k0@yang ;=&gt; * (yin yang) ;; (k0@yin k@0yang) ;; back to k0@yin with k0@yang ;; k1@yang yin = ((begin (display &apos;@) k0@yang)) ;=&gt; @ yang = k1@yang ;=&gt; * (yin yang) ;; (k0@yang k1@yang) ;; back to k0@yang with k1@yang ;; back to k0@yang, so prev yin is k0@yin yang = k1@yang ;=&gt; * (yin yang) ;; (k0@yin k1@yang) ;; back to k0@yin with k1@yang ;; k2@yang yin = k1@yang ;=&gt; @ yang = k2@yang ;=&gt; * (yin yang) ;; (k1@yang k2@yang) ;; back to k1@yang with k2@yang ;; back to k1@yang, so prev yin is k0@yang yang = k2@yang ;=&gt; * (yin yang) ;; (k0@yang k2@yang) ;; back to k0@yang with k2@yang ;; back to k0@yang, so prev yin is k0@yin yang = k2@yang ;=&gt; * (yin yang) ;; (k0@yin k2@yang) ;; back to k0@yin with k2@yang yin = k2@yang ;=&gt; @ yang = k3@yang ;=&gt; * (yin yang) ;; (k2@yang k3@yang) ;; back to k2@yang with k3@yang ;; back to k2@yang, so prev yin is k1@yang yang = k3@yang ;=&gt; * (yin yang) ;; (k1@yang k3@yang) ;; back to k1@yang with k3@yang ;; back to k1@yang, so prev yin is k0@yang yang = k3@yang ;=&gt; * (yin yang) ;; (k0@yang k3@yang) ;; back to k0@yang with k3@yang ;; back to k0@yang, so prev yin is k0@yin yang = k3@yang ;=&gt; * (yin yang) ;; (k0@yang k3@yang) ;; back to k0@yin with k3@yang yin = k3@yang ;=&gt; @ yang = k4@yang ;=&gt; * (yin yang) ;; (k3@yang k4@yang) ;; back to k3@yang with k4@yang ... 感覺大概就是來來回回，每次到 k0@yin 時，就會產生 k(n+1)@yang，然後拿這個 k(n+1)@yang 跳到最遠端的 k(n)@yang 重新往回滾，就像海浪一般。 12345678910111213141516171819(yin0&gt;yang0) | +-------------+ v(yin0&gt;yang1)&lt;-(yin0 yang0) | +----------------------------+ v(yin0&gt;yang2)&lt;-(yin0 yang1)&lt;-(yang0 yang1) | +-------------------------------------------+ v(yin0&gt;yang3)&lt;-(yin0 yang2)&lt;-(yang0 yang2)&lt;-(yang0 yang2) | +----------------------------------------------------------+ v(yin0&gt;yang4)&lt;-(yin0 yang3)&lt;-(yang0 yang3)&lt;-(yang0 yang3)&lt;-(yang0 yang3) | +--- ... ... ... continuation 的紀錄大概就到這裡，tspl 裡面有五個練習，Exercise 3.3.[1-5]，這裡有 Exercise 3.3.[1-4] 的解答。 之後應該會對 CPS 的部份做一次探討。]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>fp</tag>
        <tag>lambda</tag>
        <tag>scheme</tag>
        <tag>lisp</tag>
        <tag>continuation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[簡明 Arch 安裝指南]]></title>
    <url>%2F2019%2F06%2F06%2Farch-install%2F</url>
    <content type="text"><![CDATA[裝 Arch 第二次就上手～ script這是總結，可以一次執行： 可用以下指令安裝：1curl https://gist.githubusercontent.com/nobodyzxc/5e9bb4d6134dfa5e9a98709ae9b945b3/raw | bash 安裝前準備USB flash installation media首先我們要準備一支 live USB。下載好 Arch Linux ISO 檔 先用 lsblk 看要安裝的 USB。1234567NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTsda 8:0 0 465.8G 0 disk├─sda1 8:1 0 256M 0 part /efi├─sda2 8:2 0 449.5G 0 part /└─sda3 8:3 0 16G 0 part [SWAP]sdb 8:16 1 15G 0 disk└─sdb1 8:17 1 15G 0 part wiki:1dd bs=4M if=path/to/archlinux.iso of=/dev/sdx status=progress oflag=sync 要把 sdx 換成 sdb 那我們下載的 iso 位置為 /home/zxc/Downloads/archlinux-2019.02.01-x86_64.iso 所以我們的指令為： 1sudo dd bs=4M if=/home/zxc/Downloads/archlinux-2019.02.01-x86_64.iso of=/dev/sdb &amp;&amp; sync 開機接著我們將 USB 裝上欲安裝的主機，然後 開啟電源後按 F12 （我的桌機） ESC + 電源鍵（我的筆電）選擇開機硬體。 因為我們要用 GRUB 引導程序（可以選擇要開機的硬碟，雙系統可以用）所以選擇 USB 有 UEFI 的選項。 選擇後應該會長這樣： 選錯了會長這樣： 以 root 進入 zsh。 zsh 設定鍵盤 default US 有需要再參考 wiki。啟動模式 同上。 接上有線網路，然後 dhcpcd，ping archlinux.org 查看狀態是否成功。 更新時間 timedatectl set-ntp true，timedatectl status 查看是否成功。 硬碟切割看你要把 archlinux 裝在哪顆硬碟上，此次為 /dev/sda。 fdisk /dev/sda 進入 fdisk prompt。 先創造 GPT table。1command: g 切 /efi1234command: npartition number: (default=1)first sector: (default=2048)last sector: +260M 切 / （後來我因為裝 cuda, 會佔用 /usr 空間，所以提升至 64G）1234command: npartition number: (default=2)first sector: (default)last sector: +32G 切 swap，我有 16G RAM，切 16G swap (多切一點ww）。1234command: npartition number: (default=3)first sector: (default)last sector: +16G 切 /home，切完。1234command: npartition number: (default=4)first sector: (default)last sector: (default) 更換磁區類型，可以用在鍵入 t 後用 L 查看所有類型。 /efi =&gt; EFI System(type 1) / =&gt; Linux filesystem(type 20) swap =&gt; Linux swap(type 19) /home =&gt; Linux filesystem(type 20) 123command: tpartition number: 1partition type: 1 123command: tpartition number: 2partition type: 20 123command: tpartition number: 3partition type: 19 123command: tpartition number: 4partition type: 20 以設定進行切割並離開。1command: w 格式化硬碟vfat 格式化 /efi 分區。1mkfs.vfat /dev/sda1 ext4 格式化 / 及 /home 分區。12mkfs.ext4 /dev/sda2mkfs.ext4 /dev/sda4 格式化 swap 分區。12mkswap /dev/sda3swapon /dev/sda3 掛載切好的磁區12345mount /dev/sda2 /mntmkdir /mnt/bootmount /dev/sda1 /mnt/bootmkdir /mnt/homemount /dev/sda4 /mnt/home 安裝鏡像站設定（加速用，非必要）vim /etc/pacman.conf 加入交大鏡像站。 1234567891011[core]Server = http://archlinux.cs.nctu.edu.tw/$repo/os/$archInclude = /etc/pacman.d/mirrorlist[extra]Server = http://archlinux.cs.nctu.edu.tw/$repo/os/$archInclude = /etc/pacman.d/mirrorlist[community]Server = http://archlinux.cs.nctu.edu.tw/$repo/os/$archInclude = /etc/pacman.d/mirrorlist 開始安裝系統套件。1pacstrap /mnt base base-devel linux linux-firmware 系統配置fstab生成 fstab 檔案，定義儲存設備的初始化和連接系統方式。 -U 用 UUID 分類定義，-L 則用分割標籤，我們前面切磁碟沒上標籤，所以用 -U 吧。 1genfstab -U /mnt &gt;&gt; /mnt/etc/fstab change root切進硬碟當 root 囉！ 1arch-chroot /mnt 時區 &amp; 語言 &amp; 網路123# ln -sf /usr/share/zoneinfo/Region/City /etc/localtimeln -sf /usr/share/zoneinfo/Asia/Taipei /etc/localtimehwclock --systohc 先裝個 vim 比較順手，vi 不太順。1pacman -S vim 編輯 /etc/locale.gen 反註解 en_US.UTF-8 UTF-8 及 zh_TW.UTF-8 UTF-8。然後用 locale-gen 生成檔案。 加入環境變數 echo &quot;LANG=en_US.UTF-8&quot; &gt; /etc/locale.conf。 設定電腦名稱。 我決定叫他卡巴內里了。1echo &quot;kabaneri&quot; &gt; /etc/hostname vim /etc/hosts 最後一行加上：123127.0.0.1 localhost::1 localhost127.0.1.1 kabaneri.localdomain kabaneri 建立開機映像檔 &amp; 設定密碼12mkinitcpio -p linuxpasswd 啟動載入程式 &amp; 安裝網路工具123pacman -Sy grub os-prober efibootmgrgrub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=grubgrub-mkconfig -o /boot/grub/grub.cfg # warnning here WARNING: Failed to connect to lvmetad. Falling back to device scanning. 不用太擔心這個 warnning。 1pacman -S net-tools wireless_tools dhclient wpa_supplicant 重開前先設定好 dhcpcd。1234systemctl enable dhcpcd.serviceexitumount -R /mntreboot 安裝系統後手動設定 DNS（防雷）1echo &quot;nameserver 8.8.8.8&quot; &gt;&gt; /etc/resolv.conf 用戶new user named zxc 12345pacman -S sudovim /etc/sudoers # uncomment %wheel ALL=(ALL) ALLuseradd -m -u 1001 zxcpasswd zxcusermod zxc -G wheel 下載 yaydo follows as normal user 123git clone https://aur.archlinux.org/yay.gitcd yaymakepkg -si 桌面環境i3 擁護派一定要 i3。然後既然是桌機，配備又好，那就漂亮點，裝 deepin 吧 :) Deepin reference 值得注意的是，我用上文 lightdm-deepin-greeter 還是 blank screen，lightdm-gtk-greeter 也怪怪的。所以改用 lightdm-webkit2-greeter（需要 yay）。然後主題使用 Aether（水尬靠杯）。我又叛逃了，現在使用的是 Litarvan。（因為發現 Aether 不能記憶我上次使用的桌面系統） 123sudo pacman -S xorg xorg-server deepin deepin-extrayay -S lightdm-webkit2-greeteryay -S lightdm-webkit-theme-aether 接著設定 dm，deepin 用的是 lightdm，這部份 yay 自動幫你做，你可以確認一下。 1vim /etc/lightdm/lightdm.conf 找不到原本的 #greeter-session=example-gtk-gnome，而是已經被換成：1greeter-session=lightdm-webkit2-greeter 接下來把 dm 加到啟動設定。12systemctl start lightdm.service # 在命令列啟用，先是試開不開得起來，以免悲劇systemctl enable lightdm.service # 成功之後再下這行，開機後永久啟用 i3wm reference 1sudo pacman -S i3-gaps i3lock i3status 中文化 &amp; 輸入法123456yay -S ttf-dejavu ttf-droid ttf-freefont ttf-hack ttf-liberationyay -S adobe-source-code-pro-fonts cantarell-fonts gsfonts powerline-fonts ttf-freefontyay -S noto-fonts noto-fonts-emoji ttf-roboto ttf-roboto-mono noto-fonts-cjksudo pacman -S ibus ibus-chewing# ibus-daemon &amp; 才能用喔，要 autostart 要看你是什麼桌面環境，再進行設定。# 然後進 ibus-setup 添加中文輸入法 ibus daemon referencedaemon program autostart Google Chrome123yay -S google-chrome# or chromiumsudo pacman -S chromium reference: archlinux wiki 電腦故我在]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[functional thursday ＃73]]></title>
    <url>%2F2019%2F05%2F03%2Fpi-cal%2F</url>
    <content type="text"><![CDATA[π-calculas 不負責任筆記 Concurrency vs Parallelismcompile normal program into parallelism program? Hard! make changes on program as little as possible! parallelism ⇒ multi-processor, multi-processes concurrency ⇒ single-processor, multi-processes make write wrong program harder? Concurrent model CSP ⇒ process - process event π-calculas ⇒ channel - channel message passing process algebra π-calculas is the most complex one, but useful π-calculasSend and receive are atomic operation1234567891011121314151617SquareServer = c(x) . c&lt;x^2&gt; . SquareServer-- SquareServer is recursiveP1 = c&lt;3&gt; . c(x) . ∅-- a client want to get square of 3P2 = c&lt;4&gt; . c(y) . ∅-- a client want to get square of 4main = SquareServer | P1-- run SquareServer, P1 at the smae time.let &lt; &gt; = sendlet ( ) = receivelet c = channellet . = endlet ∅ = stop Error?12345SumServer = C(x) . C(y) . C(x + y) . SumServerP1 = C&lt;3&gt; . C&lt;5&gt; . C(x) . ∅P1 = C&lt;4&gt; . C&lt;6&gt; . C(x) . ∅-- may cause race or deadlock Give every process unique channel!123456SumServer = νd . c&lt;d&gt; . d(x) . d(y) . d&lt;x + y&gt; . SumServerP1 = c(d) . d&lt;3&gt; . d&lt;5&gt; . d(x) . ∅P2 = c(d) . d&lt;6&gt; . d&lt;4&gt; . d(x) . ∅SumServer | P2 | P1-- no race or deadlock! More powerful server?12SumServer = (νd . c&lt;d&gt; . d(x) . d(y) . d&lt;x + y&gt; . ∅) | SumServer-- calculate and provide other service at the same time! Define such operator1P = !Q = Q | P = Q | Q | Q | ... Math server12345678910-- ⊳ select-- ⊲ choiceMathServer = νc . ms&lt;c&gt;where c ⊳ &#123; ADD → c(x) . c(y) . c&lt;x + y&gt; . ∅; NEG → c(x) . c(-x) . ∅&#125; | MathServeruser = ms(c) . c ⊲ ADD . c&lt;3&gt; . c&lt;4&gt; . c(x) . ∅ MathServer throw select operation? how?12345678910MathServer = νc . ms&lt;c&gt; . worker c | MathServerworker c = c ⊳ &#123; ADD → c(x) . c(y) . c&lt;x + y&gt; . worker c; NEG → c(x) . c(-x) . worker c; END → ∅&#125; | MathServer-- worker need to receive "c" ?! function call?user = ms(c) . c ⊲ ADD . c&lt;3&gt; . c&lt;4&gt; . c(x) . ∅ No function call! use a w(orker) channel to pass “c”123456MathServer = νc . ms&lt;c&gt; . w&lt;c&gt; | MathServerworker = !(w(c) . c ⊳ &#123; ADD → c(x) . c(y) . c&lt;x + y&gt; . w&lt;c&gt; . ∅ ; NEG → c(x) . c(-x) . w&lt;c&gt; . ∅; END → ∅&#125;) Dinning phylosophers in π-calculas omit Basic Rulesidentity and association rule 12345(P | Q) | R ≡ P (Q | R)P | Q ≡ Q | PP | ∅ ≡ PP ≡ Q ⇒ R | P == R | Q reduction rule 12proc = a&lt;x&gt; . P | a(y) . Q → P | Q [x / y]-- should substitute y to x fisrt(?) 12w&lt;a&gt; . a&lt;3&gt; . P | w(z) . z(x) . b&lt;x + 3&gt;→ a&lt;3&gt; . P | a(x) . b&lt;x + 3&gt; axiom relating restriction and parallel 123456789(νx . P) | Q ≡ νx . (P | Q) if Q not contains x(νa . w&lt;a&gt; . a&lt;3&gt; . P) | w(z) . z(x) . b&lt;x + 3&gt;≡ νa(w &lt;a&gt; . a&lt;3&gt; . P | w(z) . z(x) . b&lt;x + 3&gt;)→ νa(P | b&lt;6&gt;)...→ νa . ∅→ ∅ Type system in π-calculas process is untyped channel is typed Γ ⊢ P Dual type$c : (?Int . !Int . ∅)^{⊥} = !Int . ?Int . ∅$ Type inference$\frac{Γ, x:t, y:s ⊢ P}{Γ, x:?s . t ⊢ x(y) . P}$ $\frac{Γ ⊢ y:s \quad Γ, x:t ⊢ P}{Γ, x:!s . t ⊢ x \langle y . P}$ note x:t not x:t, y:s $\frac{Γ_{1} ⊢ P \quad Γ_{2} ⊢ Q}{Γ_{1} ∘ Γ_{2} ⊢ P | Q}$ if $x ∈ Γ_{1}$ is $t$then $x ∈ Γ_{2}$ need to be $t^{⊥}$ type preservation Γ ⊢ e : τ ∧ e -&gt; e’ ⇒ Γ ⊢ e’ : τ Γ ⊢ e : τ e value ∃ e’, e → e’ linear logiccut rule]]></content>
      <categories>
        <category>Memoir</category>
      </categories>
      <tags>
        <tag>lambda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FLOLAC'18]]></title>
    <url>%2F2018%2F07%2F27%2Fflolac18%2F</url>
    <content type="text"><![CDATA[為期兩個禮拜的課程結束，我收穫到了什麼呢？ 楔子對 Functional 的追求，我隻身一人到了台大上課，然而心中的那份悸動，究竟能不能被滿足呢？ 在集訓前，因為專題和教授會面，偶然得知了講師竟然是高中校友，不過因為我高中不是電研社，所以對於這位大我十屆的學長感到非常陌生。 看了他的部落格，望著那豐富的經歷，對自己研究的東西侃侃而談，以及對於教學的心得，友人們的回應等等，是和自己截然不同的角色呢。 漸漸的知道自己周遭，也是有人受到相同的東西吸引，投入相關的領域，開始覺得不是那麼的孤獨。 不過光是受到吸引是不夠的，要付出才能夠積累。希望我不再獨行。 結果去那還是沒認識半個人 XD 接下來會記一下學到的東西吧。課程有四部份，以下摘自教材，為我最有印象的幾個部份。 函數式編程 Functional Programming Induction這門課主要不是在介紹 Haskell Fancy 的 Features，而是以 Proof 和 Programming 做結合，想要證明一些性質。像是 take n xs ++ drop n xs == xs。 介紹了一些 Haskell 基本的東西後，玩過了 Wholemeal Programming 後，一切便都從 Induction 開始。 就以證明 take n xs ++ drop n xs == xs 為例吧。 1234567891011121314151617take n [] ++ drop n [] == [] ,valid.take n (x:xs) ++ drop n (x:xs)= &#123; by take's definition &#125;(x : take (n - 1) xs) ++ drop (n - 1) xs= &#123; by ++'s property, [] ++ ys == ys, (x:xs) ++ ys == x : (xs ++ ys) &#125;x : (take (n - 1) xs ++ drop (n - 1) xs)= &#123; by induction &#125;x : xs, valid. Fold-Fusion1234-- considersquare x = x * xsumsq xs = sum (map square xs) 其中 sumsq 的複雜度是 O(2N)，先做出一個 square 後的 list 再 sum 起來。 但我們應該可以將它化成 O(N) 吧？一邊 sum 一邊 square。 例如改寫成1sumsq = foldr (\e acc -&gt; square e + acc) 0 如此的轉換稱作 fold fusion。 TheoremGiven f :: a → b → b, e :: b h :: b → cand g :: a → c → c, we have h . foldr f e = foldr g (h e), if h (f x y) = g x (h y) for all x and y. 那這個 g function 該如何推導呢？看起來最重要的就是這個 g function 了啊。 我們以 sumsq 做例子。首先，我們要將 h . foldr f e 和 sum . map square 做匹配。 很直覺地 h == sum 而 map square == foldr f e將 map 化為 foldr : map f == foldr (mf f) where mf f = \e acc -&gt; f e : acc 123map square== foldr (mf square) []== foldr (e acc -&gt; square e: acc) [] 所以 h == sum, f == (e acc -&gt; square e: acc), e == [] 利用 h (f x y) = g x (h y) 123456789101112131415161718192021h (f x y)= &#123; match &#125;sum ((e acc -&gt; square e : acc) x xs)= &#123; elimination lambda &#125;sum (square x : xs)= &#123; definition of sum &#125;square x + sum xs= &#123; let ssq x y = square x + y &#125;ssq x (sum xs)= &#123; match &#125;g x (h y) 所得 g == ssq, h == sum, xs == [] 最後由 h . foldr f e = foldr g (h e) 得到 sum . foldr (mf square) []) == foldr ssq (sum []) 即為 foldr ssq 0，就是原先改寫的 foldr (\e acc -&gt; square e + acc) 0 Reduce Complixity by Tupling123-- considersteep [] = Truesteep (x:xs) = steep xs &amp;&amp; x &gt; sum xs steep 用來判斷一 List 之元素差是否保持陡峭。如果該元素大於其後所有元素之和回傳 True 反之 False。 考慮其複雜度，呼叫 steep 有 n 次，每次 steep 中的 sum 又需要 n 的複雜度，所以複雜度是 O(N^2)。 那有沒有辦法降低複雜度呢？比如說每次呼叫 steep 時一邊計算 sum？為了一次回傳兩個值，我們使用 tuple。 1steepsum xs = (steep xs, sum xs) 如此，steep xs = fst $ steepsum xs 現在，我們將 steepsum 變成 recursive function，實現一邊算 steep 一邊算 sum。 1234567891011121314steepsum (x:xs)= &#123; definition of steepsum &#125;(steep (x:xs), sum (x:xs))= &#123; definition of steep and sum &#125;(steep xs &amp;&amp; x &gt; sum xs, x + sum xs)= &#123; extracting sub expressions &#125;(sp &amp;&amp; x &gt; sm, x + sm) where (sp, sm) = steepsum xs 至此，我們成功的將 O(N^2) 的 steep 改寫成 O(N) 的 steep。 12345678910steep [] = Truesteep (x:xs) = steep xs &amp;&amp; x &gt; sum xs-- transformsteep xs = fst $ steepsum xssteepsum [] = (True, 0)steepsum xs = (sp &amp;&amp; x &gt; sm, x + sm) where (sp, sm) = steepsum xs Monad這又是另一段故事了，有時間再說 XD或者就跳過了，反正對於 Monad，我有預感我會自開一篇 邏輯 Logic Instuitionistic Logic and Nature Induction這門課主要講的是直覺邏輯 (Instuitionistic Logic)，跟之前在學校學的古典邏輯不太一樣。 直覺邏輯系統沒有排中律 ( ⊢ q ∨ ¬q )，但這不意謂著直覺邏輯比較弱，一個邏輯系統的強弱倚賴於將命題歸類的能力，從某種意義來說，推不出排中律意謂著直覺邏輯更加嚴格。 在直覺邏輯的 rule 大部分和古典邏輯相同。值得注意的是，直覺邏輯沒有 double negation 的 rule。 而 negation 的部份，應該是相同的 ~I: φ → ⊥ // ¬φ~I: [A … F] // ~A 這裡學到的是寫成 tree 的樣子而學校學的 Natural Deduction 是寫成 block 然後 twitter 有這個 bot 可以玩。他可以將你輸入的命題作自動推導。 .@nobodyzxc1 Provable. (upn07) pic.twitter.com/swaCztVhcA&mdash; IPC bot (@ipc_bot) July 30, 2018 之前在學校學的寫成12345678910(A ∧ B) ∧ C → A ∧ (B ∧ C)1.1 (A ∧ B) ∧ C // Assumeption1.2 C // ∧E by 1.11.3 A ∧ B // ∧E by 1.11.4 A // ∧E by 1.31.5 B // ∧E by 1.31.6 (B ∧ C) // ∧I by 1.2 and 1.51.7 A ∧ (B ∧ C) // ∧I by 1.4 and 1.62 (A ∧ B) ∧ C → A ∧ (B ∧ C) // →I by 1.1 and 1.7 Others之後還有提到 semantic of propositional logic 及 first-order logic，一樣有些 introducing 和 elimination 的 rules…就不細講了，可以透過這些 rule 可以做 structural proof 和 nature induction 的 proof。 最後就是提到 Curry-Howard correspondence，將 first-order logic 和 typed lambda calculas 對應起來。 這門課還有演示了 Agda ，感覺很好玩，用了 aquamacs 搭配 $\LaTeX$ 的語法，打出了 FLOLAC18.agda 啊～ 原來這就是利用程式輔助證明啊。有時間再入坑 然後講師還出了一題用 foldr 定義 foldl，直覺就是 reverse 一下啊，結果隔一節課後補充說只能用 lambda wwwww當下並沒有很認真想，但直覺就是像 CPS 的東東吧。過了幾天，它就在腦中跑出來了… 1foldl f e xs = foldr (\e acc -&gt; (\b -&gt; acc $ f b e)) id xs $ e Lambda 演算與型別 λ Calculas and Types 先是用 Formal Language 定義了由 0 | succ | add 組成的數。然後介紹了 SI。 Syntax of Lambda Calculas第二節課才進到 lambda calculas，lambda form 很簡單，只有 variable, application, abstraction 三條規則。 然後就用 lambda 定義了 tuple, fst, snd, nature numbers, boolean… α conversion, β conversion 啦，大概就是我之前在網路上看過的那些了。 然後提到的 Free and Bound Variables，之前在學校 LICS 課討論的 first-order logic 蠻像的。(那時候 LICS 討論 admissiable 討論蠻久的…) Properties of Lambda Calculas這邊提到的 Evaluation Strategies，剛好之前也有看過，但沒有和 Haskell 產生連結， Call-by-value strategie rightmost-outermost but not inside any λ-abstraction ex: Scheme Call-by-name strategie leftmost-outermost but not inside any λ-abstraction ex: Haskell 之前寫過 mini Scheme 的 eval/apply 終於知道和 Haskell 差在哪裡了。這也是讓 Haskell Lazy 的原因啊。(Lazy Evaluation 為一種 call-by-name 的方法) 之前看 call-by-name 只是覺得會有用這麼麻煩的方法求值的實現嗎？用 Call-by-value 不是很好嗎… 原來 Haskell 就是。 算是把以前的惑又解更開了。 有時間把 Wiki 看看吧。 Simple typed Lambda Calculas and System F算是會做 lambda calculas 的 type derivation… 但是老實說，並沒有把 System F 搞得很清楚 &gt;&lt; 並行計算模型與訊程型別 Models of concurrent computation and session types 重點就在 π Calculas，一堆 dual types 的 derivation… dual types 確保了通訊雙方 type 相對一致，確立了安全性。 π Calculas 有蠻多版本的，然後由簡單到複雜… 感覺比 λ Calculas 複雜啊～～看得眼睛花，不過這門相較於其他，算是比較簡單的了。 講師使用 Scribble 寫了簡單的 protocal 作為示範。其中 IDE 的 type checking 讓你在寫的時候就知道自己傳收兩邊的 type 有沒有寫錯。 Talk (Racket)以前學 Scheme 用的就是 Racket，沒有寫很多程式，但知道這語言潛力很大，但就是沒有一個好好的介紹，讓我入門。 Talk 介紹了 Racket，才知道他的強大。 之前看知乎上，談論到 Racket 的 Macro 很棒，但我都知其然，而不知其所以然。 今天總算是見識到啦&gt;&lt; lang power 以後 slide 也靠 Slideshow 轉 Markdown 啦～之前還不知道 Racket 有 Slideshow，還用 landslide 轉 Markdown (一個 Python 寫的工具) 後記flolac 結束幾天後，在 telegram 上的一個前端群組，偶然發現一位網友在說 type，其中描述的像是 lambda calculas (haskell) 中的 type，然後又提到 curry howard isomorphism， … 這不就是這次上的東西嗎？ 一問之下才發現，他是那坐在我後面幾排，那位旁聽的高中生啊 XD 算是結下了緣吧 :)]]></content>
      <categories>
        <category>Memoir</category>
      </categories>
      <tags>
        <tag>logic</tag>
        <tag>fp</tag>
        <tag>lambda</tag>
        <tag>flolac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[feedback]]></title>
    <url>%2F2018%2F05%2F22%2Ffeedback%2F</url>
    <content type="text"><![CDATA[上程式語言課，給老師的回饋。 葉丙成老師兩篇關於主修 CS 的文章 102657 ( CK ) 2018-03-06 10:59 0想聽聽聽同學對這篇文章的看法。 現在學 CS 會不會太晚？在程式設計之外，更該想「如何創造價值」 https://opinion.cw.com.tw/blog/profile/215/article/6232 CS 學生的優勢就是浸淫 CS 的時間比別人長。 隨著各種技術的發展，整個工具鏈的架構也越來越複雜。雖說抽象化降低了工具使用的難度，但是有些工具的使用也是需要經驗累積的。 那些工具、技術可能就是資訊科系學生可以投資的吧。比如 server 管理等等。 而以上終究只是混口飯吃的等級罷了。只要別人肯下苦工，終究還是會被替代掉的。 相對於工具的使用，CS 的學生應培養解決問題的能力。更準確的說，是用程式化思維或是用電腦來解決問題的能力。（用程式化、抽象化思維看待所有事物的能力？） CS 學生對整個 CS 領域見識應具有廣度和深度。別人也會程式，但我會的比你深比你多。別人會的是工具的使用，我們會的是工具的挑選甚至是工具的創造。 好的工具可以事半功倍。或許是在培養對好工具的獨到眼光。 就像 GUI 工具只會限制用戶，Text Mode 才能釋放所有能量 (X 學過 CS 的人，層次要是更高的。我覺得甚至是要具備一些哲學層面的東西。 設計哲學、解決問題的哲學、甚至是生活的哲學 (Link) 等等。 如此開發效率才能更高，產物才能更優雅。其他科系的可能就只是堪用而已。 遇到問題，應該要能快速擬出相關的解決辦法。而遇到的問題類型可以是很廣的。 學習洞悉問題的本質，才能對全局掌握更加透徹。 也算是在培養觸類旁通（抽象）的能力吧。 還有一點是快速上手工具的能力。玩 Linux 的東西也是為了培養這種能力吧。 折騰過得東西多了，該如何解決甚至是找替代方案，都會比較有 sense。 培養減少繞路的情況發生。能對問題有獨到的見解，以更抽象通用迅捷的方式解決問題。 身邊的例子。同學會，同學都確立方向，很多人都要往 AI 走。電資學院、電機系、資工系。看到電機系 CS 組使用 python。因為性質相似，所以想和資工的同學討論語言的東西。 發現他摸過得語言比較少。python 摸過，但是覺得把 python 當工具用。 不把 python 只是當工具，對語言本身的思想哲學有更深入的理解，應該就會有相對其他系有相對的優勢了。 有更好的答案，就是編程的能力 Orz]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[A Little Game]]></title>
    <url>%2F2018%2F02%2F21%2FA-Little-Game%2F</url>
    <content type="text"><![CDATA[這是一年多前，在知乎看到的小遊戲。 那時候玩到感覺就是這遊戲真不簡單，蘊含了很多東西在裡面。 這幾天因為朋友說無聊，所以我又翻出來玩（結果他沒玩）， 感覺得到的東西又不一樣了。 感覺從中得到了些東西，所以想探討一下。 傳送門 ^ 戳他 玩法介紹自己摸索吧，這樣最有趣，因為我也是這樣玩的 白色盤面上的工具要用光，而你的任務是利用白色盤面上所有的工具造出左上角的 Goal。其中下面黑色區域則是可選區，你可以拿或不拿其中的工具來完成你的目標。開始用滑鼠拖曳（或點擊）元件，組合出需求吧。 初見剛接觸到這遊戲，是因為看到了在推廣 FP 的貼文。其實那則貼文有兩個遊戲，而此次要提的是我覺得比較好玩的那款。玩完之後馬上推給了同學呢 w 在這遊戲中，看到了 Currying 的概念，接收了一個部件，一個半完成的工具也是一個工具。而最有趣的是他有 Higher Order Function 的思想 一個產生輸出的工具，亦可拿工具當輸入，甚至回傳工具。 還有偷換概念的部份，他會將原本比較實際的東西漸漸抽象為程式碼，到最後竟然有寫 Code 的感覺。 再見第二次碰的時候，將上次沒玩完（老實說我很好奇為啥那時沒玩完）， 通通跑過了一遍。順便拿家人當實驗品 w在變換的過程中，我發現了 Lambda 的存在。之前旁聽 Haskell 的時候，還對他不熟悉，到現在看過了一點 Lambda Calculus 相關的定義後，這次驚奇的發現在抽象的過程中，竟然跑出了 Lambda Expression，然後最後變成 JS 的 Arrow Function。 拿給家人玩時，發現普遍會發生一個問題，那就是大家會觀察不到工具的功能。可能是有 FP 經驗，所以我玩起來都知道其中那些東西的象徵意義，或是我玩遊戲比較有 sence，我去注意細節，所以玩起來特別有感覺。可是其他人玩大多都是憑感覺，有些接口也會弄不清楚可不可以接上。這邊就是我覺得他不足的地方了。雖說形狀已經有稍微強調，可是不夠明顯。或許可以用顏色表示。 還有一些關卡過於簡單，而且因為關卡順序不是很恰當，所以感覺會讓人失去興趣，感到無聊。 其實這次還發現了一個特點，那就是強制要求要用光白色盤面的規則，除了要讓你照規則走，發現一些 FP 的特性，他也可以闡發一個概念，就是如何使用原本就有的東西，巧妙的修改，而不是重新造輪子（雖然有時會比較快），但是使用原有的函式構造新的函式是 FP 一個重要的思想啊。 來總括一下此遊戲設計的所有元素吧。 點出比較重要的幾關吧。 Lv1 提了 atom，如星星，一個基本的資料型態，應該可算 Symbol。 還有就是 tool(function)，可以 input 然後 return 的。 （建議動畫可以做好點，不然普通人會把 input x return x 當成沒有事情發生） Lv2 tool can take tool as input. Lv3 tool can return const , not always variable. and they are all tools. Lv4 figure out the tool of black region. Lv5 tool can return more atoms. Lv6 tool can split the expressoin part. Lv7, 8 HOF Lv10 tool -&gt; lambda expr Lv11 boolean type Lv12, 13 boolean expr(function), true and false Lv 22 if expression (PP 的會說是 ternary operator) 嘛，還有 List , Map 之類的，懶的說了。 我很喜歡他偷換概念的部份，不過不要換太快，會令初學者措手不及。]]></content>
      <categories>
        <category>Fun</category>
      </categories>
      <tags>
        <tag>game</tag>
        <tag>logic</tag>
        <tag>fp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scheme 初學者眼中的 Haskell]]></title>
    <url>%2F2018%2F02%2F14%2FHaskellFromScheme%2F</url>
    <content type="text"><![CDATA[嘛，情人節，和 Haskell 約個會吧！ 因為學完 Scheme 後回來看 Haskell， 發現有不少地方是已經會的。 而我覺得記些基本的東西意義不大， 所以改成以一個接觸過 Scheme 的 FP 初學者角度， 重新來看待 Haskell 這個語言。 SyntaxPattern matching我記得王垠的 40 行代碼好像有 require pmatch,所以 Scheme 應該是有以 library 實現 pattern matching 的。 而 Haskell 則是內建此種語言特性，大概可以有三種地方可以用到。 函數定義，可以少去一些 if else 1234-- 注意 match 的順序性fib 0 = 0fib 1 = 1fib x = fib (x - 1) + fib (x - 2) 123456(define (fib x) ; 懶得寫 = 所以用 case (case x ; 不過 racket 其實是用 equal? [(0) 0] ; R6RS, R5RS 是用 eqv? [(1) 1] [else (+ (fib (- x 1)) (fib (- x 2)))])) 拆 tuple, list 123456789101112-- as patternall@a:b = [1, 2, 3]-- all == [1, 2, 3]-- a == 1-- b == [2, 3](a, b, c) = (1, 2, 3)-- a == 1, b == 2, c == 3-- 結合 1. 定義 sum'sum [] = 0sum' (x:xs) = x + (sum' xs) List comprehension 中 12[x + y | (x, y) &lt;-zip [1, 2, 3] [4, 5, 6]]-- ^ match Guard 感覺之前一直不能接受這個 syntax, 現在看作 cond 就好了。 書中的例子藉由 Guard 定義一個函數。12345bmiTell bmi -- *attension! no = here | bmi &lt;= 18.5 = "You're underweight, you emo, you!" | bmi &lt;= 25.0 = "You're supposedly normal. Pffft, I bet you're ugly!" | bmi &lt;= 30.0 = "You're fat! Lose some weight, fatty!" | otherwise = "You're a whale, congratulations!" 其實就是 123456(define (bmiTell bmi) (cond ((&lt;= bmi 18.5) "You're underweight, you emo, you!") ((&lt;= bmi 25.0) "You're supposedly normal. Pffft, I bet you're ugly!") ((&lt;= bmi 30.0) "You're fat! Lose some weight, fatty!") (else "You're a whale, congratulations!"))) Where 用於函數定義中，於定義下方加入 where syntax 做簡易的 binding。 12345678bmiTell weight height -- *attension! no = here | bmi &lt;= 18.5 = "You're underweight, you emo, you!" | bmi &lt;= 25.0 = "You're supposedly normal. Pffft, I bet you're ugly!" | bmi &lt;= 30.0 = "You're fat! Lose some weight, fatty!" | otherwise = "You're a whale, congratulations!" where bim = weight / height ^ 2 -- where 裡面可作 pattern matching 亦可定義函數 嘛，就是 Scheme 裡的 nested define 嘛。 1234567(define (bmiTell weight height) (define bim (/ weight (* height height))) (cond ((&lt;= bmi 18.5) "You're underweight, you emo, you!") ((&lt;= bmi 25.0) "You're supposedly normal. Pffft, I bet you're ugly!") ((&lt;= bmi 30.0) "You're fat! Lose some weight, fatty!") (else "You're a whale, congratulations!"))) Let 當然也有 let expression，bindings 和 exprs 用 in 關鍵字隔開 bindings 中可以用 pattern matching，也可以用 ; 隔開每個 binding list comprehension 中也可以用 let bind 一些值，注意有效範圍。 12 [nv | (x, y) &lt;- lst, let nv = x + y, nv &gt; 10]-- ^^ x-----------x ^^^^^^^^^^^^^^ ^^^^^^^ Case pattern matching 本質上是 case exprs 的語法糖。 而在我看來 pattern matching 在 Scheme 中也就是 cond 的語法糖 (null? 等函數去判斷） 所以在 case exprs 可以解決的基本上 Guard 也可以解決，而回歸原始，用 if else 解決。 重點是記得適用場景，Guard 用在 Bool，case 用在 pattern matching。 之前這邊一直沒有摸清楚。 123case expression of pattern -&gt; result pattern -&gt; result pattern -&gt; result HOF 與 Scheme 最大的不同就是 Haskell 會自己做 currying。 善用 currying 特性就可以很自然的做出 partially applied function。 如此就不用再寫 lambda 去餵 HOF 啦～ 還有就是 map 的力量，Haskell 的 map 是 map :: (a -&gt; b) -&gt; [a] -&gt; [b]， 和 Scheme 的 map 不太一樣，Scheme 因為是動態語言所以 map 吃的 function 彈性比較大。 如 (map + &#39;(1 2 3) &#39;(1 2 3)) 後面可以接幾個 list 端看前面 function （加號的話可以無限啦～）。 而 Haskell 要用 + 號則是用 zipWith，zipWith (+) [1, 2, 3] [1, 2, 3]。 Haskell map 和 zipWith 也就只是差在 unary 和 binary，依舊不能和 Scheme map 比。 或許有其他方法吧，這就要研究一下 Haskell 的 var args 用法了。 一些 Haskell hof 可以玩玩 123map, filter,foldl, foldr, foldl1, foldr1,scahnl, scanr, scanl1, scanr1 注意 foldl 系列的第一個參數的型態是 (b -&gt; a -&gt; b)所以在寫 lambda 的時候是 (\ e acc -&gt; expr)而 foldr 系列則是 (a -&gt; b -&gt; b)寫 lambda 的時候則是 (\ acc e -&gt; expr) Lambda lambda 寫法 \ bindings -&gt; exprs $ 的使用 $ 號使用，一般下一個元素都會當作參數向左結合， 但是前面有 $ 號的話，就可以不用被當成參數， 直接當成 function apply 到右邊（後面）的參數上， 直到完成，再餵回前面去。 還有可以將 data 當 func 特性，如 map ($ 3) [(4+),(10*),(^2),sqrt] Function composition 嘛，就是 f(g(x)) 可以用 Haskell 寫成 f . g。就是這樣而已！ 注意的是 apply to arguments 的部份搭配個 $ , 也就是 f . g $ arg Module transpose 函數可以反轉一組 List 的 List。 光看中文還蠻容易誤解的，但看了他的例子及看了英文後，這不就轉置嗎？ 馬上想到 Python 是用 Scheme, Python 是用 zip (map) 達成，但考慮到 Haskell 的靜態特性，所以把 var arg 裝到一個 list 成為一個新函數。 Self suspicion 以下是一年前做 Note 提出的疑問。 Q: tuple likes struct, while list likes array ?A: 在念計概的時候有提到 record 這個概念，就是不同型態的資料的集合，所以 tuple 和 struct 都可以算是 record 的一種實作吧。不過 Haskell 也有 Record Syntax。而 list 不是 array，就是 linked list，要 array 的話 Scheme 有 vector，Haskell 裡應該也有類似的東西。 Q: 試想 zip implement, 是 zip (x:xs) (y:ys) = (x, y) : zip xs ys 而不是 list comprehension [… | x&lt;-xs, y&lt;-ys, …]，這兩種使用 list element 的方式差別是什麼，後者如何以 recursion 實現。並考慮一下迴圈是否有類似的狀況。A: 上述的 List Comprehension 會是兩層迴圈的情形（窮舉），所以沒辦法使用。之後看到唐鳳介紹 FP 時用 Haskell List Comprehension 做的例子，估計這 List Comprehension 的內部也有個 zip 的實現在用 pattern matching 去為參數配對吧。]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>fp</tag>
        <tag>haskell</tag>
        <tag>lambda</tag>
        <tag>scheme</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cpp STL Hack]]></title>
    <url>%2F2017%2F10%2F05%2Fcpp-stl%2F</url>
    <content type="text"><![CDATA[為了應付比賽，又很久沒有使用 STL，所以做個總攻略。 How to start1using namespace std; pair Header 1#include&lt;utility&gt; Non-member funcs 12345678910 /* make a pair without assign types */pair&lt;int , string&gt; pr = make_pair(1 , "str"); /* assignment opertor overloading *//* comparaision between pairs */ cout &lt;&lt; (make_pair(1 , 2) &lt; make_pair(1 , 3)) &lt;&lt; endl;/* 1 *//* C++ 11 */swap(pr0 , pr1); Member vars 1234cout &lt;&lt; pr.first &lt;&lt; endl;/* 1 */cout &lt;&lt; pr.second &lt;&lt; endl;/* 2 */ tuple (C++11) Header 1#include&lt;tuple&gt; Non-member funcs 123456789/* make a tuple */tuple&lt;int , char , string&gt; t(10 , 'c' , "string");/* make tuple quickly */auto tp = make_tuple(1 , 1);/* get element */cout &lt;&lt; get&lt;2&gt;(t) &lt;&lt; endl;/* string */ vector Header 1#include&lt;vector&gt; How to construct 12345678910111213const int size = 5;const int init_val = 1;vector&lt;int&gt; vi(size , init_val);/* 1 1 1 1 1 */vector&lt;vector&lt;int&gt; &gt; vvi(size , vector&lt;int&gt;(size , init_val));// 5*5 's 1// or you can alloc byvector&lt;vector&lt;int&gt; &gt; vi2d;for(int i = 0 ; i &lt; size ; i++) vi2d.push_back(vector(size , init_val)); How to iterate 12345678910/* 珍惜生命，多用 auto *//* iterator 為 .begin() .end() .rbegin() 及 .rend() */for(vector&lt;vector&lt;int&gt; &gt;::iterator vit = vvi.begin() ; vit != vvi.end() ; vit++ , cout &lt;&lt; endl) for(vector&lt;int&gt;::iterator it = vit-&gt;begin() ; it != vit-&gt;end() ; it++) cout &lt;&lt; *it &lt;&lt; ' ';for(int i = 0 ; i &lt; vvi.size() ; i++ , cout &lt;&lt; endl) for(int j = 0 ; j &lt; vvi[i].size() ; j++) cout &lt;&lt; vvi[i][j] &lt;&lt; ' ' &lt;&lt; endl; Member funcs Capacity and Accessor .size .empty .front .back .resize123456vi.resize(3)/* reduce to 3 elms */vi.resize(5 , 4)/* expand to 5 elms and stuff new elms to 4 */vi.resize(10)/* expand to 10 elms and stuff new with default val (0) */ Modifiers .push_back .pop_back .insert.insert(iter , val).insert(iter , size_t , val).insert(iter , iter_beg , iter_end) .erase.earse(iter).earse(iter_beg , iter_end) .swapva.swap(vb) .clear function overloads relational swapswap(va , vb) ref: std vector C++ — deep or shallow copy stack Header 1#include&lt;stack&gt; Member functions .empty .size .top .push .pop Non-member func relational operator queue Header 1#include&lt;queue&gt; Member functions .empty .size .front .back .push .pop Non-member func relational operator priority_queue Header 1#include&lt;queue&gt; Member functions .empty .size .front .back .push .pop Non-member func relational operator set Header 1#include&lt;set&gt; How to construct 1234567int data[] = &#123;1 , 2 , 3 , 4&#125;;set&lt;int&gt; iset(data , data + 4);/* iter.begin() and iter.end() */set&lt;int&gt; yset(iset);set&lt;float , bool(*fp)(float)) fset; How to iterate 12345/* iterator 為 .begin() .end() .rbegin() 及 .rend() */for(set&lt;int&gt;::iterator it = iset.begin() ; it != iset.end() ; it++) cout &lt;&lt; *it &lt;&lt; ' ';cout &lt;&lt; endl; Member functions Capacity .empty .size .max_sizecheck if the set has enough size to store elements Modifiers .insertinsert element .erase.erase(iter).erase(val).erase(iter_beg , iter_end) .swapswap two setsa.swap(sb) .clear Observersread it yourself Operations .find .count .lower_boundReturn iterator to lower bound 1234&#123;1 , 2 , 3&#125;.lower_bound(1) ^&#123;1 , 3 , 5 , 7&#125;.lower_bound(2) ^ .upper_boundReturn iterator to upper bound 1234&#123;1 , 2 , 3&#125;.upper_bound(2) ^&#123;1 , 3 , 5 , 7&#125;.upper_bound(2) ^ .equal_rangeGet range of equal elements.Return pair of iters 12345&#123;1 , 2 , 3&#125;.equal_range(2) ^ second iter ^ first iter&#123;1 , 3 , 5 , 7&#125;.equal_range(2) ^ first &amp; second iter map Header 1#include&lt;map&gt; How to construct 12345map&lt;string , int&gt; dict;dict["hello"] = 0;dict["world"] = 1;map&lt;string , int&gt; ydict(dict.begin() , dict.end());map&lt;string , int&gt; zdict(dict); /* copy constructor */ How to iterate 1234/* iterator is a pointer to pair */for(map&lt;string , int&gt;::iterator it = dict.begin() ; it != dict.end() ; it++) cout &lt;&lt; it-&gt;first &lt;&lt; ' ' &lt;&lt; it-&gt;second &lt;&lt; endl; Member functions Capacity &amp; Element access .empty .size .max_sizecheck if the map has enough size to store kpr [] Modifiers .insertlet me explain it .erase.erase(iter).erase(key).erase(iter_beg , iter_end) .swap .clear Observersread it yourself Operations .findget the iterator .countcheck the kpr exist .lower_boundReturn iterator to lower bound .upper_boundReturn iterator to upper bound .equal_rangeGet range of equal elements.Return pair of iters algorithm Header 1#include&lt;algorithm&gt; Non-modifying iter find(iter_beg , iter_end , val) iter find_if(iter_beg , iter_end , pred_fp) iter search(iter_beg , iter_end , seq_beg , seq_end)Search range for subsequence iter find_first_of(iter_beg , iter_end , range_beg , range_end)Find element from set in range iter find_end(iter_beg , iter_end , sub_beg , sub_end)Find last subsequence in range int count(iter_beg , iter_end , val)(int -&gt; std::ptrdiff_t) int count_if(iter_beg , iter_end , pred_fp) bool equalequal(iter0_beg , iter0_end , iter1_beg)equal(iter0_beg , iter0_end , iter1_beg , pred_fp) Modifying copy(first_iter , last_iter , result_iter) swap reverse Sorting sortsort(first , last)sort(first , last , comp_fp) Heap push_heap pop_heap make_heap sort_heap is_heap (c++11) Min/Max min max min_element max_element Binery_search do it yourself maybe Other next_permutation(first , end); prev_permutation(first , end); overload operator123456inline bool operator==(const X&amp; lhs, const X&amp; rhs)&#123; /* DIY */ &#125;inline bool operator!=(const X&amp; lhs, const X&amp; rhs)&#123; return !(lhs == rhs); &#125;inline bool operator&lt; (const X&amp; lhs, const X&amp; rhs)&#123; /* DIY */ &#125;inline bool operator&gt; (const X&amp; lhs, const X&amp; rhs)&#123; return rhs &lt; lhs; &#125;inline bool operator&lt;=(const X&amp; lhs, const X&amp; rhs)&#123; return !(lhs &gt; rhs); &#125;inline bool operator&gt;=(const X&amp; lhs, const X&amp; rhs)&#123; return !(lhs &lt; rhs); &#125; paste from:operator overloading vim script]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C Type Defination to English]]></title>
    <url>%2F2017%2F07%2F15%2Fctype2en%2F</url>
    <content type="text"><![CDATA[PL 教授給的 8 頁 Func Ptr 閱讀材料。 那就來玩一下吧。 wait to refer:rule The flip side of this is that you have to deal with old mistakes and with compatibility problems. For example, I consider the C declarator syntax an experiment that failed.-Bjarne Stroustrup, in his SlashDot interview on 2/25/2000. 我嘗試寫成 Haskell 的定義型態。那個 Type* 能理解就好了 （逃 https://cdecl.org/ long *a(int) 1declare a as function (int) returning pointer to long 1a :: Int -&gt; Long* long (*b(int)) 1declare b as function (int) returning pointer to long 1b :: Int -&gt; Long* long (*c)(int) 1declare c as pointer to function (int) returning long 1c :: (Int -&gt; Long)* long *d(int)(char) 1declare d as function (int) returning function (char) returning pointer to long 1d :: Int -&gt; (Char -&gt; Long*) long (*e(int))(char) 1declare e as function (int) returning pointer to function (char) returning long 1e :: Int -&gt; (Char -&gt; Long)* long (*f)(int)(char) 1declare f as pointer to function (int) returning function (char) returning long 1f :: (Int -&gt; (Char -&gt; Long))* void qsort(void *, size_t, size_t,int (*)(const void *, const void *)) 1234567declare qsort as function (pointer to void, size_t, size_t, pointer to function (pointer to const void, pointer to const void) ) returning int) returning void 1qsort :: Void* -&gt; Size_t -&gt; Size_t -&gt; (Void* -&gt; Void*)* -&gt; Void start with the identifier look to the right for brackets[ ] or parentheses() look to the left for asterisks remember that parentheses group finally, look at the type (eg. int) reference link 重點是先往右讀，然後讀到括號，再往左讀，如此往復。先找變數宣告名稱，\w+ 後跟的是 ( ，則此宣告為一函數，否則為變數。 先往右，遇到 (，為函數，參數為 fnArg。往左讀，遇到 *，回傳為一指標，指向 long。long *fn(fnArg) -&gt; fn :: FnArg -&gt; Long* 如果再右邊還有括號，則他的回傳指標為函數指標，其參數為該括號內容。long *fn(fnArg)(argOfAfnRtnedByAFn) -&gt; fn :: FnArg -&gt; (ArgOfAfnRtnedByAFn -&gt; Long)* 如果後面一直有括號，其指的函數類型就一直向右 eval 括號就好了。long *fn(fnArg)(argOfAfnRtnedByAFn)(argOfAfnRtnedByAFnRtnedByAFn)-&gt; fn :: FnArg -&gt; (ArgOfAfnRtnedByAFn -&gt; (ArgOfAfnRtnedByAFnRtnedByAFn -&gt; Long*)) 注意指標可能出現的位置。long (*fn(fnArg)(argOfAfnRtnedByAFn))(argOfAfnRtnedByAFnRtnedByAFn)-&gt; fn :: fnArg -&gt; (ArgOfAfnRtnedByAFn -&gt; (ArgOfAfnRtnedByAFnRtnedByAFn -&gt; Long)*) long (*fn(fnArg))(argOfAfnRtnedByAFn)(argOfAfnRtnedByAFnRtnedByAFn)-&gt; fn :: fnArg -&gt; (ArgOfAfnRtnedByAFn -&gt; (ArgOfAfnRtnedByAFnRtnedByAFn -&gt; Long))* 有時指標不只一個，看著辦吧。 Illegal combinations include: - cannot have an array of functions ()() - cannot have a function that returns a function ()[] - cannot have a function that returns an array 所以其實上面五項，應該只有幾個是 Illegal 的（from reference） 其實回傳函數指標和回傳函數在 C 裡是一樣的事情 變數名前有*代表他是一個指標，long *ptr -&gt; ptr :: Long* 如果右邊有閉括號，代表他是一個函數指標。long (*ptr)(argOfApointedFn) -&gt; ptr :: (ArgOfApointedFn -&gt; Long)* 其指的函數類型就一直向右 eval 括號就好了。long (*ptr)(argOfApointedFn)(argOfAFnRtnedByAFnPointedByAPtr)-&gt; ptr :: (ArgOfApointedFn -&gt; (ArgOfAFnRtnedByAFnPointedByAPtr -&gt; Long))* 一樣，有時指標不只一個，看著辦吧。 我都快搞不清我在寫啥了（Haskell 的 Type 表達比較好理解（]]></content>
      <categories>
        <category>Note</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Cygwin Beginner Guide]]></title>
    <url>%2F2017%2F05%2F30%2Fbasic-linux%2F</url>
    <content type="text"><![CDATA[本篇主要內容為在 Cygwin 下一些簡單的 BASH 用法。 事先聲明 Cygwin != Linux，它是 Windows 下一個模擬 Linux terminal 的介面。 關於 Cygwin 的安裝。 不過可以注意的是套件的部分只要多載一個 wget 就夠了，其他部分（如 vim 等）用 apt-cyg 下載就好。(apt-cyg 的使用置於文末） 當你開啟 Cygwin 時，先不要嫌它醜，這之後可以慢慢調。（或是直接抓現成的設定檔 存到~/.bashrc） WHERE AM I ?首先，你可以看到有個命令列。 12userName@computerName ~$ 記住，你現在位置為家目錄，如果沒有特別改命令列的話，你可以發現命令列是以~表示家目錄。 你現在有的只有簡單命令列，你可以先下個pwd指令來確認自己現在在檔案系統中的位置。 不過你會發現這個位置有點奇怪，怎麼在 windows 的檔案總管中沒有見過， 這是因為 Cygwin 要模擬 linux 的檔案環境， 將你當初安裝的路徑選為根目錄 (root)，長出一套類似 linux 的檔案環境（樹狀）。（而且 windows 的檔案分層是使用\，linux 則是使用/）1234567891011121314151617181920/ &lt;- 根目錄 (root)，為 windows 下的某個資料夾|├── bin &lt;- 很多指令（程式）存放的位置├── cygdrive│ ├── c &lt;- 注意！這裡可以切到 C 槽│ └── d &lt;- 注意！這裡可以切到 D 槽├── dev &lt;- 對 linux 來說，這裡有很多硬體裝置有關的檔案├── etc &lt;- Linux 開機（這裡就是開 Cygwin) 的一些設定檔├── home│ └── ~ &lt;- 家目錄，你現在的位置├── lib &lt;- 程式語言的一堆 library├── sbin &lt;- 放著系統管理者常用的指令├── tmp &lt;- 一般使用者暫存檔案的地方，重要的東西不要放這├── usr &lt;- 跟系統息息相關的目錄│ ├── bin│ ├── etc│ ├── include│ ├── lib│ └── tmp└── var &lt;- 系統工作預設的工作目錄。 你現在的位置其實和 windows 還是有應對關係的， 你可以下個cygpath -w $HOME來確認自己家目錄在 windows 的位置。cygpath -w $PWD來確認自己當前 在 windows 的位置。 動身知道了自己的位置後，接下來就是改變位置了， 想像一下，你現在是一個人，每個資料夾是個房間，你現在知道自己的位置，再來就是走來走去了。 你可以先下個ls指令，看一下現在的房間和哪幾間相連著。(ls 是 list 的縮寫） 沒意外的話是空空如也啊。 可以再下個ls -a，(a 是 all 的意思），把所有隱藏的房間（和物品 -&gt;文件） show 出來。(ls -la 可以詳列更多訊息，l 是 long list format 的意思） 你可以發現多了 . 和 .. 這兩個房間。 .表示當前這間房間。至於為啥要有這種設計，你之後就會知道了。..則是上一層房間。方才我們說過，linux 的檔案系統是以樹狀的結構存在。 接下了可以開始切換了，可以使用cd dirname切換路徑。使用cd ..切到上一層。(cd 是 change directory 的縮寫）沒有任何 output，只是命令列 (prompt) 稍稍改變了一下，這代表你成功切到上一層了。 沒有消息就是好消息。—— linux 的哲學 沒有 output 大多就是程序正常運行。 接著下ls，看到的目錄應該就是你的家目錄，注意一點的是，名字為什麼不是~呢？ 因為~只是個縮寫啦。 關於回到家目錄，你可以用cd ~ 或 cd。 對於路徑，這裡 有更詳細的說明。 建立捷徑linux 和 windows 的捷徑其實是不太一樣的，在 cygwin 中不可用 .lnk 的捷徑。 在家目錄如果想要建一個到桌面的捷徑，你可以下 ln -s /cygdrive/c/Users/$USER/Desktop/ ~/desktop。 然後你在家目錄可以使用 cd desktop 移動到桌面了。 創建、刪除與移動 創建當你要創建一個資料夾的時候使用 mkdir dirname。當你要創建一個空文檔的時候使用 touch filename。 補充一點，檔案大致分為兩種類型 text 和 binary，text 是存 ASCII 和 UTF-8 一類，一般用 vim 或記事本等編輯。binary 是 non-text file，例如可執行的二進制檔案。不過 .py 檔是純文本也可執行，因為它是直譯的。但是說到底，在電腦裡都是以二進制的方式儲存啦 :P 刪除當你要移除一個檔案時 rm filename。當你要移除一個空資料夾的時候 rmdir dirname。當你要移除一個資料夾（空或非空都適用）和裡面的東西 rm -r dirname。(-r flag 是 recursively 的意思） 注意！使用 rm 刪除資料就真的回不來了，它沒有資源回收垃圾桶。 移動（或更名）當你要移動檔案（或資料夾）A 到資料夾 B 時 mv a b。當你要重新命名檔案（或資料夾） A 為 B 時 mv a b。 看出來了嗎，若 B 資料夾不存在，則會視為更名，存在則是移動。要非常小心的一點是 B 如果是已存在的檔案時，B 會被 A 覆蓋，而 A 命名為 B。還有一點要注意的是，Windows 下大小寫其實是不分的。（但你在 Cygwin 中打字還是要分大小寫）。 關於強大的 TAB 和 Arrow Keys , 快捷鍵等 tab假設你要切換到一個名字很長的資料夾時，cd aDirWithALongLongLongName，你可能會打到瘋掉，這時可以適時的使用 tab 鍵。cd aDirW 打幾個字後敲一下 tab 鍵，他會盡可能挑出當前可能的選項幫你補上去。 arrow keys你方才輸過的指令可以用方向鍵上下來叫出來。 快捷鍵（有興趣請走這)輸過的指令也可以按ctrl-r然後敲幾個字來叫出，如果不是想要的那個，繼續按ctrl-r，選到後按enter。 指令幫助每一道指令都是一支程式，在 linux 下你可以用以下方法得到使用說明。 man 指令名稱其實 man 就是一支程式，它會幫你去找其他指令的相關使用說明。 指令名稱 -h 指令名稱 --help一般來說程式會內建一些使用說明，加個 flag 試試看吧。 資料流重導向使用資料流也是一項很重要的技能。簡單來說資料流可以分做 stdin , stdout , stderr。 stdin 是檔案內容輸入至程式（指令）的一條流向。（鍵盤輸入 — linux 下裝置也有檔案，在 /dev 中，也是 stdin） 當你寫好一支簡單的程式 (output.py)，他會要求輸入，然後輸出至螢幕。 1print(input()) 但你每次要輸一長串相同的東西很麻煩，這時候你可以寫在檔案 (input.txt) 裡面。 1hello world! It&apos;s my first python script ...... 每次就不用執行python output.py再從鍵盤輸入同樣的東西了。寫好 input.txt 後只要下python output.py &lt; input.txt，它就會幫你把 input.txt 的內容輸進 output.py。 stdout 程式輸出至檔案的那條流向（螢幕在 linux 下也是檔案喔）。 你現在下個 ls 的指令，它會輸出至螢幕，如果你要將它重導至檔案 (justLsOut.txt)，可以下個ls &gt; justLsOut.txt。如果本來沒有 justLsOut.txt 檔案，它會創一個 justLsOut.txt，然後把內容塞進去。如果已經有 justLsOut.txt 的話，它會覆蓋掉 justLsOut.txt 的內容，然後塞 ls 的結果進去。 但如果你不想要覆蓋掉原本內容呢？你也可以將 ls 的結果加在 justLsOut.txt 後面。使用 ls &gt;&gt; justLsOut.txt 就好了。&gt;&gt;是 append 的用法。 stderr 是當有錯誤發生時，程式輸出至檔案的那條流向。不過一般是跟 stdout 一起輸到螢幕。如果你將 stdout 導到其他地方，螢幕剩下的就是 stderr 了。 更多如 cat &gt; file.txt &lt;&lt; end , ls nonexsitfile.txt &gt; out.txt 2&amp;&gt;1 用法請走這除此之外，你還可以學學 pipe 使用 apt-cyg 管理套件cygwin 安裝的 setup.exe 基本上就是一個套件管理器，但是它是 GUI 的，而且還要點一堆選項，感覺很慢。 如果你追求速度又 prefer Text Mode 的話，你可以試試別人寫的 shell script － apt-cyg。 用起來感覺就像 apt-get 一樣。 apt-cyg 如何使用呢？首先先把 apt-cyg 的 script 複製下來， 接著你有以下幾種方式（任選其一即可）把內容貼到檔案，放到家目錄。 貼在記事本裡面，不要用 word，然後存到家目錄 (cpath -w $HOME) 中，假設存為 script.txt。 下指令cat &gt; script.txt 然後滑鼠右鍵貼上，按 enter，接著ctrl-d跳出。 你可以下cat script.txt看貼上有沒有成功，cat指令是將檔案內容輸出至螢幕（沒有參數時是將鍵盤輸入輸出）。接著可以用 mv script.txt apt-cyg。（別懷疑，我會將檔案叫做 script.txt 只是要你練習 mv） 有裝 wget 的話，在家目錄使用 wget https://raw.githubusercontent.com/transcode-open/apt-cyg/master/apt-cyg （你可以 cat 一下 apt-cyg 看看有沒有下載成功） 再來 chmod a+x apt-cyg。（讓這個腳本擁有執行權限，有興趣看看關於 linux 檔案權限 的內容） 接著 ./apt-cyg install vim。你就有 vim 可以用了。（我的 vim 入門可以走這)（和 Windows 不一樣的是，當前目錄可執行的檔案要執行一定要加 ./) 你可以將 apt-cyg 移到 /bin （根目錄底下的 bin 目錄），這樣就能在任何地方呼叫它而不用使用./了。 mv apt-cyg /bin。（對這方面有興趣可以看看$PATH的介紹） 然後如果對有帶$號的變數有興趣的話，可以看看環境變數。 其實如果檔案沒有執行權限，可以使用bash file.sh 來執行一個 shell 腳本。道理和 python 一樣。 其他有用套件tmux — 一項強大的終端切割螢幕工具。使用 apt-cyg install tmux 取得。在沒有設定檔的情形下ctrl-b是 prefix 鍵。 使用ctrl-b ?開始玩玩看吧。也可以使用我調校過的設定檔 (prefix 是 ctrl-a)，將設定檔存為 ~/.tmux.conf。 結束你玩完 Cygwin 後，可以不用按右上角的X，你可以打個 exit 或按ctrl-d來結束它。]]></content>
      <categories>
        <category>Fun</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>cygwin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[About Python's container]]></title>
    <url>%2F2017%2F05%2F29%2Fpython-container%2F</url>
    <content type="text"><![CDATA[Python 感覺入門很久了，但對於容器的使用一直感到很生疏，遂筆記一篇，期能熟之。 Question我對於 Python 的一些存在一直不能感到理解，就是這些對容器的 function 了。為啥不要做的像 Ruby 一樣把它做成物件下的 function 呢？等到理解的時候或許就能向 The Zen of Python 靠近一點了吧。果然正式提出疑問，才有動力去找解答。 (a) For some operations, prefix notation just reads better than postfix — prefix (and infix!) operations have a long tradition in mathematics which likes notations where the visuals help the mathematician thinking about a problem. Compare the easy with which we rewrite a formula like x*(a+b) into x*a + x*b to the clumsiness of doing the same thing using a raw OO notation. 123恩... 習慣問題嗎？嗯？len(&quot;asd&quot; + &quot;efg&quot;) 和 (&quot;asd&quot; + &quot;efg&quot;).length() 嗎？確實，前面的比較有數學感覺，恩，FP 的感覺（ (b) When I read code that says len(x) I know that it is asking for the length of something. This tells me two things: the result is an integer, and the argument is some kind of container. To the contrary, when I read x.len(), I have to already know that x is some kind of container implementing an interface or inheriting from a class that has a standard len(). Witness the confusion we occasionally have when a class that is not implementing a mapping has a get() or keys() method, or something that isn’t a file has a write() method. 123用 len(container) 就比較不用去思考 container 是不是繼承某一個 class 的實作。確實，我常常被 javascript 的 string.length 和 C++ 的 string.length() 混淆（好像有點離題，不過要思考是屬性還是方法確實也是會混淆 Non-member functions repr(container) -&gt; 轉成可以讓被 eval 的字串符（哼哼，人家 Scheme 才沒這麼複雜呢）。 len(container) -&gt; 取得容器長度 del(container[idx]) -&gt; 移除容器的第幾個節點 reversed(container) -&gt; 回傳一個 reversed 的 iterator （注意，不是原本的容器類型，所以要再轉。) 常用的就這些，其他有遇到再加吧。 一些 infix 的就不說了。以上是 prefix。 Methods of containers123function( param ) intro ([param]) -&gt; 參數可有可無 ( ... ) -&gt; 不定長度 help(tuple)tuple 的特性就是 read-only，他的元素一旦確立下來就不能用 = 改。替代方法可以轉成 list 再轉回來，不然就是直接再造一個新的 tuple。 tuple(iterable) 建構子可以輕易的將其他容器 (iterable) 轉為 tuple 容器。（沒有參數等同 new 一個空的） T.count(elm) 回傳元素個數出現次數。 T.index(elm) 回傳元素出現的第一次出現的 index。 help(list)list(iterable) 建構子可以輕易的將其他容器 (iterable) 轉為 list 容器。（沒有參數等同 new 一個空的） L.append(elm) 將元素加到 list 的尾端。 L.clear() 清空容器。 L.copy() new 出一個一模一樣的 copy。(lb = la.copy() 和 lb = la 是不一樣的！) L.count(elm) 回傳元素個數出現次數。 L.extend(iterable) 把其他容器 (iterable) append(Scheme 向） 在後面。 L.index(elm) 回傳元素出現的第一次出現的 index。 L.insert(idx , elm) 在 index 之前插入元素。 L.pop([idx]) 移除 idx 位置的元素，並回傳該元素。（沒有參數等同對最後一個元素進行操作） L.remove(elm) 移除第一個出現的元素。 L.reverse() 對 list 進行倒轉（不回傳值）。 L.sort([key = None , reverse=False]) 排序。 help(set)set(iterable) 建構子可以輕易的將其他容器 (iterable) 轉為 set 容器。（沒有參數等同 new 一個空的） S.add(elm) 增加元素到 Set 中。 S.clear() 清空容器。 S.copy() new 出一個一模一樣的 copy。(sb = sa.copy() 和 sb = sa 是不一樣的！) S.difference(set ...) 回傳差集。 S.difference_update(set ...) S = S.difference(Set …)。應該可以算是語法糖的東西。 S.discard(elm) 移除一個元素，如果它存在於 set 中，不存在也不會噴錯。 S.intersection(set ...) 回傳交集。 S.intersection_update(set ...) S = S.intersection()。 S.isdijoint(set) 不相交回傳 True。 S.issubset(set) 如果 S 是參數的子集回傳 True。 S.issuperset(set) 如果 S 是參數的超集回傳 True。 S.pop() 移除任一元素並回傳（我試過了，好像也不是那麼隨意）（如果 empty 發生 KeyError） S.remove(elm) 移除一元素（必須存在於 set 否則發生 KeyError) S.symmetric_difference(set) 回傳集合為刪除交集的聯集部分。 S.symmetric_difference_update(set) S.symmetric_difference 的語法糖。 S.union(set ...) 聯集。 S.update(set ...) 感覺就是 S.union_update()，不過這裡直接叫 update 了。 help(dict)dict(iterable) 建構子可以輕易的將其他容器 (iterable) 轉為 dict 容器。（沒有參數等同 new 一個空的） D.clear() 清空容器。 D.copy() new 出一個一模一樣的 copy。(db = da.copy() 和 db = da 是不一樣的！) D.fromkeys(iterable [, value = None]) 可以拿其他容器當 key 和指定預設的 value。 D.get(key [, d = None]) 用法和 D[key] 很像但 D[key] 如果不存在會噴 KeyError， get 則噴 d。 D.items() 回傳一個物件提供 view of items（然後可以幹嘛？) D.keys() 回傳一個物件提供 view of keys（然後可以幹嘛？) D.pop(key [, d]) 移除 key 和其 item， d 是 key 不存在時的回傳值，但跟 get 不同，預設噴 KeyError。 D.popitem() 移除一 key , item pair 並回傳該 pair 為 tuple。(dict 為 empty 噴 KeyError) D.setdefault(key [, d]) 和 D.get(key , d) 同，如果不存在 k 則設定 D[key] = d。 D.update([dict | assignment]) 更新字典，assignment 用法比較特殊，字串可以不用 quotation。 D.values() 回傳一個物件提供 view of values。（然後可以幹嘛？)]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>oop</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ruby Note]]></title>
    <url>%2F2017%2F04%2F27%2FRuby-Note%2F</url>
    <content type="text"><![CDATA[Codecademy 之 Ruby 速記。 原來 Ruby 和 DSL 很有淵源啊（喃喃）。 剛學沒多久教授就提到了，Ruby 主要是 SmallTalk + Lisp 佐一點 C。 On the path to enlightenment. wait to refer: Ruby Guides done! Lots of docs Basic跟 Python 一樣是動態、腳本語言，所謂變數只是 name binding，(Philosophy 可是很不同呢～) 用法跟 Python 也一樣， assignment 即宣告。every thing is object。 basic special operator122 ** 4 # 16[1 , 2 , 3] &lt;=&gt; [3 , 1] # cmp recursively Comment12345# single line comment=beginmultiple line comment=end Functions!語法糖，將 Method 返回結果回存 Object。.，function chainning 在 OO 可以玩得很溜。 IO123456gets.chomp# chomp 去除前後空白字元，包括 \n \t 一類puts "#&#123;var&#125; with new line"print "#&#123;var&#125; without new line" array object’s methods123arr = [1 , 4 , 2 , 5 , 3]arr.sort!arr.sort! &#123; |a , b| -(a &lt;=&gt; b) &#125; # lambda is great! string object’s methods123456789101112# 不用加括弧啊"string".to_sym # symbol will explain later"string".intern # "string" =&gt; :symbol"string".length"string".reverse"string".upcase"string".downcase"string".capitalize"string".include? "des to search" # 回傳 bool，很有 lisp style 的 ?"string".gsub(/replace/ , "new string")"string".gsub!(/replace/ , "new string") # 直接取代，我只是要強調 ! 的位置"string".split # split string to array of string define a function12345678def functionName(argA , argB) # do somethingend# 由於靈活的語法，可以 omit ()def add x , y x + y # omit return will take last exp as return valueend Control Flow基本的東西，稍微記一下。 123456789101112131415161718192021222324252627if 1 == 1 # do somethingelsif 'a' == 'b' # 注意 keyword # do somethingelse # do somethingend# 有點微妙，因為有 end ，所以不用管縮排，儘管看起來跟 python 有點像。# 但 if statement 後沒有 : 或 &#123; 表示開頭（他拿 \n 做辨認？)。# 不，如果寫成 one line 還是要加 ;if true; puts "true" end# 可是有更潮的 one line if （後面）# if not , syntax sugarunless what # do somethingelse # do somethingend# 這個語法糖，我也是醉了， do something if whatstatement unless expstatement if exp# Ruby 之禪 discuss later Loop12345678910111213141516171819202122232425262728293031while exp # do somethingend# the syntax sugar of 'while not'until exp # do somethingend# 1 2 3 4for i in 1...5 print "#&#123;i&#125; "end# 1 2 3 4 5for i in 1..5 print "#&#123;i&#125; "endloop do # do something next if while # same as 'continue' in C's break if whatendloop &#123; # do something &#125; # inf loopnumber = 10number.times&#123; print "Do you need some Wow?" &#125; # wow...(doge# Array 會提及物間迭代器用法 - each 關於 loop 的流程控制 123456789101112131415&#123; # block of loop# redo jump here to restart it , so amazing...redo if doRedobreak if doBreaknext if doNextreturn if doReturn # return func (not loop)# next jump here wait to start a new iteration&#125;# break jump to here Array1234567891011121314array = [1 , 2 , 3 , 4]array = [1..4] # not the same !!# 這是 array 塞一個 range 物件，做迭代會迭出一個物件array = (1..4).to_a # this !array.each do |var| print "#&#123;var&#125;"end(1..4).each do |var| # 直接用 range 物件迭代就一樣了 print "#&#123;var&#125;" # 體會一下end# iterationarray.each &#123; |var| print "#&#123;var&#125;" &#125; # lambda in haskell ? Hash1234567891011121314151617181920212223242526272829303132hashTb = &#123; "one" =&gt; 1 , "two" =&gt; 2 , "three" =&gt; 3 &#125;# we can take symbol as key , too!symTb = &#123; :one =&gt; 1 , :two =&gt; 2 , :three =&gt; 3 &#125;symTbInRuby1pt9 = &#123; one: 1 , two: 2 , three: 3 &#125;# 冒號要跟緊 symbol，不然不會過puts hashTb["one"]# create empty hashaHash = Hash.newaHash["A"] = "a"# iterationhashTb.each&#123; |key , value| puts "#&#123;key&#125; , #&#123;value&#125;" &#125;# special iterationshashTb.each_key &#123; |key| puts k &#125;hashTb.each_value &#123; |value| puts value &#125;hashTb.each do |key , value| puts "#&#123;key&#125; , #&#123;value&#125;"end# if acess no exist key will get nil (fp? wwwwww)# you can set default "nil" to other valuemy_hash = Hash.new("no such key , sorry")# select 用法，wow 有 database 的感覺呢。# 等等，他就是 FP 的 filter 嘛...puts symTb.select&#123; |k , v| v % 2 == 1 &#125; Symbol這個資料型態也很潮，跟字串不一樣，相同的字面值只佔一個空間。（因為這個特性，所以做 hash 比較優秀嗎？)12345678910111213puts "string".object_id# 12886316620puts "string".object_id# 12886316480puts :symbol.object_id# 801628puts :symbol.object_id# 801628sym = :my_symbol # : 後面要連起來s_sym = sym.to_s # 轉成 string Symbol vs String in Hash from Codecademy123456789101112131415require 'benchmark'string_AZ = Hash[("a".."z").to_a.zip((1..26).to_a)]symbol_AZ = Hash[(:a..:z).to_a.zip((1..26).to_a)]string_time = Benchmark.realtime do 100_000.times &#123; string_AZ["r"] &#125;endsymbol_time = Benchmark.realtime do 100_000.times &#123; symbol_AZ[:r] &#125;endputs "String time: #&#123;string_time&#125; seconds."puts "Symbol time: #&#123;symbol_time&#125; seconds." Zen of Ruby (Improvement of Syntax)one line 系列，不用 end。123puts "She will accept me" if she_love_meputs "She will reject me" unless she_love_me swich case in c , select case in vb , case when in ruby!非常之靈活。注意 then and else(without then)。1234567891011121314151617181920212223242526# 基本用法，像 Ccase lang when "java" then puts "so long..." # add then if whole command in one line when "cpp" puts "so powerful..." # or omit then with a new line when "ruby" puts "so fun!" else puts "I like the else!"endcase lang when "chinese" , "english" # 逗號 puts "I can" else puts "I can't"endcase num when 1..10 then puts "1 to 10" # GNU extension 也有 when 11..20 then puts "2 to 20"endcase # 如果 case 沒給，甚至可以像 VB 用 expr when false then puts "false" when 1 + 1 == 2 then puts "true"end magic operator! (for me)123456contain = nilputs containcontain ||= "not nil" # re assignment if nilputs containcontain ||= "re assignment" # won't re assignment because it's not nilputs contain zen of iterations123456789object of num5.times&#123; |n| somthing.. &#125;object of list , map or otherobj.each&#123; |a , ... | somthing... &#125;object which can enum (num , char ...)5.upto(6)&#123; |x| puts x &#125;'a'.upto('z')&#123; |x| puts x &#125; check if obj will response the method or not1obj.respond_to?(:func) # take care , it take a functino name(symbol) as param pushy ( &lt;&lt; operator )1234567[1 , 2 , 3 , 4].push(5)# equal to[1 , 2 , 3 , 4] &lt;&lt; 5"asdf " + "asdf"# equal to"asdf " &lt;&lt; "asdf" string interpolation1puts "list to string #&#123;[1 , 2 , 3 , 4, 5]&#125;" # eq to to_s function ternary operator1true ? 1 : 2 # like c Implicit ReturnLisp 的感覺，當在 let 執行多個 expression 會回傳最後一個 expression。Ruby 是將 function 看成 let 回傳最後一個 statement。 Blocks , Procs , and Lambdas前面看了這麼多東西，應該可以察覺 lambda 的概念在哪了吧，沒錯，就是 block !（然而這不是 Ruby 真正的 lambda ，他還有個 lambda obj){ |x| x * 2 } 和\x -&gt; x * 2 in Haskell 和lambda x : x * 2 in Python 和(lambda (x) (* x 2)) in Scheme 和function(x) { return x * 2 } in JavaScript 都是 lambda。不知不覺也學了好多 lambda 呢，不過我在思考可不可以直接拿來 apply 這件事。Haskell 和 Scheme 不用說，Python 可，JavaScript 和 Ruby 目前不會用。1lambda&#123; |x| puts x &#125;.call(8) # Ruby 1(function(x)&#123; console.log(x); &#125;)(8) // JavaScript High Order Function123# collect 就是 FP 中常用的 map[1 , 2 , 3].collect &#123; |n| n % 2 == 0 &#125;[1 , 2 , 3].map &#123; |n| n % 2 == 0 &#125; # 也有 map 這個 function yield =&gt; 傳入的 lambda function 代名詞（變數名）。一般我們 FP 在定義 High Order Function 時都要為 take 的 function 取變數名。但 Ruby 在只有傳入一個 function 時，可以直接拿 yield 做關鍵字來 take function。123456789# 我做一個簡單的 mapdef myMap li rtn = [] li.each&#123; |e| rtn &lt;&lt; yield(e) &#125; rtn # Implicit returnendputs "#&#123;myMap [1 , 2 , 3 , 4] &#123; |x| x ** 2 &#125;&#125;"# 藉由 ruby 強大的 DSL 能力，括號少很多 Proc To DRY感覺可以用 JavaScript 的 lambda fn 和其 name binding 體會一下差異1234567# ruby 要將 lambda(Proc) 綁到變數上，注意 P 大寫mul = Proc.new &#123; |a , b| a * b &#125; # create a block and =&gt; new proc object # proc obj 比 block obj 成熟 # 且可以用 call method 重複呼叫 # block 是一次性的puts mul.call 1 , 2# 因為是物件導向 Proc 物件要當 Function 用要用 call 1234mul = function(x , y)&#123; return x * y &#125;// create lambda and bind it to a new nameconsole.log(mul(1 , 2));// 剛好相反，因為物件都是 Function 模擬的 w Proc to Block可以體會到，把 Block 綁到 Proc 是常用的手段，但要 Proc 如何用在 High Order Function 呢？前面我們學到 Block 使用是在 function 後加 Block 然後使用 yield 關鍵字。12345678用前面的 myMap 再加一個 double 為例子。double = Proc.new &#123; |x| x * 2 &#125;puts myMap([1 , 2 , 3] , &amp;double) # &amp; 號 做的就是把 Proc =&gt; Block# equal toputs myMap([1 , 2 , 3]) &#123; |x| x * 2 &#125;# butputs myMap([1 , 2 , 3] , &#123; |x| x * 2 &#125;) # errorputs myMap([1 , 2 , 3]) &amp;double # error Proc 應用在 map 上。123num_s = [1 , 2 , 3].map(&amp;:to_s)# 注意冒號，要用 symbol 轉 proc 來 call# （其實我在想是不是 obj method 的關係） 補：Codecademy 上沒有講，但我覺得很奇怪的一點－難道我只能用 yield 嗎？FP 上都可以把 function 傳進來用變數表示，Ruby 要怎麼做？123456789101112# 這樣做（重寫 myMap)def myMap li , &amp;fn # 記得傳進來要當 proc or lambda 物件來看了 rtn = [] li.each&#123; |e| rtn &lt;&lt; fn.call(e) &#125; # 所以要用 call method rtn # Implicit returnenddouble = Proc.new&#123; |e| e * 2 &#125;#以下兩種都可以過puts "#&#123;myMap([1 , 2 , 3 , 4] , &amp;double&#125;"puts "#&#123;myMap([1 , 2 , 3 , 4])&#123; |e| e * 2 &#125;&#125;" 所以看起來 yield 的優勢是將它當成 function 看。而這種方式則是當作 object 看。 真正要介紹 Ruby 的 lambda 了，由於是 OO 語言，所以 lambda 是 obj。用法基本和 proc 相似。12proc_double = Proc.new &#123; |x| x * 2 &#125;lambda_double = lambda &#123; |x| x * 2 &#125; difference between lambda and Proc lambda 會檢查 param 數量，Proc 若沒吃夠直接當 nil lambda 會返回控制權， Proc 回直接執行（對 2. 我有一套自己的解釋法但不知對不對，詳見例） 123456789101112131415161718def ProcTst proc_s = Proc.new&#123; return "inner Proc" &#125; # 我視 proc.call 為直接像 macro 炸開 proc_s.call # 所以該行替換成 return "inner Proc" # 所以就直接 return 了 return "ProcTst" # 不走這行endputs ProcTst # ==&gt; "inner ProcTst"def LbdaTst lbda_s = lambda &#123; return "inner Lbda" &#125; # lambda 直接再進一個 stack lambda.call # 所以該行回傳結果是 "inner Lbda" return "LbdaTst" # 然後 return "LbdaTst"endputs LbdaTst # ==&gt; "LbdaTst" 應該只有我會這麼亂想吧…12345678910def ReturnTst yield # 所以該行回傳結果是 "inner Lbda" return "ReturnTst" # 然後 return "LbdaTst"endputs ReturnTst&#123; return "rtn of block" &#125;puts ReturnTst &amp;Proc.new&#123; return "rtn of Proc" &#125;puts ReturnTst &amp;lambda&#123; return "rtn of lambda" &#125;# =&gt; 結果都是 unexpect return 結語，要用一次性且只有一個的 function 用 block + yield 就好然後一次性多個 就傳 lambda or Proc object 加上 &amp; 吧。 OOPCapitalize your class name1234class Dog # =&gt; 強制大寫，不然不給過，立意良善enddoge = Dog.new "lion" # create a instance constructor - initialize他的建構子不是拿 class 的名字不過說實在的，我覺得 initialize 有點冗長…12345class Dog def initialize name @name = name # 詳見下例 endend variable type - global , class , instance12345678$animal_num = 0 # 全域變數，帶 $ 字頭class Dog @@dog_count = 0 # 屬於 class 的 var，就是 static 啦，帶 @@ 字頭 def initialize name @name = name # 帶 @代表成員變數，哼哼不用煩惱變數就是爽 @@dog_count += 1 endend function belongs class -&gt; self.fn or ClassName.fn1234567891011121314151617181920class Dog @@dog_count = 0 # 屬於 class 的 var，就是 static 啦，帶 @@ 字頭 def initialize name @name = name # 帶 @代表成員變數，哼哼不用煩惱變數就是爽 end # class function 就是 static 的 function 啦 def self.get_dog_num; @@dog_count end # 意會一下用 ; 而不用換行（想一想為啥 end 前不用呢）=begin 或者可以寫成 def Dog.get_dog_num @@dog_count end=endend inheritance with &lt; 1234567891011121314151617181920212223class Animal def initialize sound @sound = sound end def howling puts @sound endendclass Dog &lt; Animal @@dog_count = 0 # 屬於 class 的 var，就是 static 啦，帶 @@ 字頭 def initialize name @name = name # 帶 @代表成員變數，哼哼不用煩惱變數就是爽 end def self.get_dog_num # 就是 static 的 function 啦 @@dog_count endenddoge = Dog.new "lion"doge.howling # 糟糕，doge 叫不出來，怎麼辦 需要 overriide ，因為 doge 叫不出來。12345678910111213141516171819class Dog &lt; Animal @@dog_count = 0 # 屬於 class 的 var，就是 static 啦，帶 @@ 字頭 def initialize name @name = name # 帶 @代表成員變數，哼哼不用煩惱變數就是爽# @sound = "Wolf!" # 除了 overriide，也可以將 sound 直接改掉 end def self.get_dog_num # 就是 static 的 function 啦 @@dog_count end def howling # overriide howling puts "Wolf!" endenddoge = Dog.new "lion"doge.howling # doge 叫出來了 super =&gt; 調用 parent 的 同名 function（不只是 initialize 喔）1234567891011121314class Dog &lt; Animal @@dog_count = 0 # 屬於 class 的 var，就是 static 啦，帶 @@ 字頭 def initialize name @name = name # 帶 @代表成員變數，哼哼不用煩惱變數就是爽 super "Wolf!" # 剛剛的直接取代不漂亮，直接調用 Animal 的 initialize end def self.get_dog_num # 就是 static 的 function 啦 @@dog_count endenddoge = Dog.new "lion"doge.howling # doge 叫出來了 Ruby 不支援多重繼承，因為 so ugly，他用 mixin(mod + class)! public , private , protectclass var , instance var 預設都是 privateclass function , instance function 預設都是 publicprotect 就是繼承者可用嘛，不多說。123456789101112131415161718192021222324252627282930class Dog &lt; Animal @@dog_count = 0 # 屬於 class 的 var，就是 static 啦，帶 @@ 字頭 public def initialize name; @name = name; super "Wolf!" end def self.get_dog_num; @@dog_count end private def any_fn_you_want_to_be_private; endend# orclass Dog &lt; Animal @@dog_count = 0 # 屬於 class 的 var，就是 static 啦，帶 @@ 字頭 def initialize name; @name = name; super "Wolf!" end def self.get_dog_num; @@dog_count end def any_fn_you_want_to_be_public; end def any_fn_you_want_to_be_private; end public :any_fn_you_want_to_be_public # 注意是用 symbol private :any_fn_you_want_to_be_private # 對 class fn 做 public , private 比較特別 # 要使用 private_class_method 這個關鍵字 # 在此略過不討論end attr_reader , attr_writer , attr_accessor我們常常在 OOP 使用 get 和 set ，但實在太冗了，Ruby 給我們自動製造 function 的方法。用起來和 public 變數一樣。 123456789101112131415161718class Dog attr_reader :age # 為 age 做 get 的 function attr_writer :food # 抱歉，江郎才盡了 attr_accessor :name # get and set both # 注意後面是加 symbol def initialize name , age , food @name = name @age = age @food = food endenddoge = Dog.new "lion" , 3 , "null"puts doge.namedoge.name = "frog"puts "#&#123;doge.name&#125; : #&#123;doge.age&#125;"doge.food = "meat" Modulemodule Name =&gt; 一樣 Capitalizedmodule 只能有 Const（大寫的 name)namespace 呼叫 （和 C++ 一樣可以用 ::)require ModuleName （就是 import in python 啦）1234567891011121314151617181920require "date" # 可以使用 Date module 的東西，注意小寫及 stringmodule Rectangle Edge = 4 # 廢話 def Rectangle.area wid , len len * wid end def Rectangle.perimeter wid , len (len + wid) * 2 end def shape "Rectangle" endendputs Rectangle::Edgeputs Rectangle.area 5 , 10 include module in classmixin -&gt; imitating multiple inheritance123456789class Paper # Ummm... include Rectangle def initialize len , wid @len = len @wid = wid endendputs m.shape # Rectangle 但我在想 Rectangle 的 area 如果寫成 instance fn 的話給 Paper inheritance ，area 怎麼直接用到 Paper 的 wid &amp; len 呢… extend -&gt; as class fn拿 parent 的 instance fn 當自己的 class fn12345678910111213141516module Rectangle Edge = 4 # 廢話 def area wid , len # 注意 area , class fn =&gt; instance fn len * wid end def shape "Rectangle" endendmodule Square # class 也可以用 extend 喔，效果一樣 extend Rectangleendputs Square.area 5 , 5 # 就是這樣 結語，其實我覺得還是有許多問題的，不過這真的是 OOP 面的問題。 寫在後面Ruby 還有一些比較特別的東西，記在最後面。 單件方法 (singleton method) 就是 instance create 後，可以直接重新 def instName.func。據說是從 prototype-based 來的。(JavaScript 就是 prototype-based) 恩，有點 WTF 的東西…感覺整個 obj_new 是個 lambda…v 是 obj_new closure 裡的 name binding。 123456789101112def obj_new v = 0 get = lambda&#123; v &#125; set = lambda&#123; |x| v = x &#125; return get , setendobj_r , obj_w = obj_newputs obj_r.callobj_w.call 5puts obj_r.call 恕我用癟腳的 Scheme 模擬一下。最近剛好在教 FP 模擬 OOP :)12345678910111213141516(define obj-new (lambda (v) (list (lambda () v) (lambda (x) (set! v x)) ) ) )(define obj (obj-new 0))(define obj-r (car obj))(define obj-w (cadr obj)) ; 沒有 pattern matching 真麻煩(display (obj-r)) (newline)(obj-w 5)(display (obj-r)) (newline) 其實如果不要照 Ruby 的範例，我 scheme 是比較想寫成 123456789101112131415(define obj-new (lambda (v) (lambda (sym . param) (cond ((equal? sym 'get) v) ((equal? sym 'set) (set! v (car param))) (else 'func-not-def) ) ) ) )(define obj (obj-new 0))(display (obj 'get)) (newline)(obj 'set 5)(display (obj 'get)) (newline) 例外處理 對應 C++ ， Java 的 throw , catch ，Ruby 有著 begin , rescue 。 12345678910111213141516171819202122def get_file_first_line err_try = 0 print "&gt; " fname = gets.chomp begin file = open(fname) rtn = file.gets rescue if err_try &lt; 3 print "&gt; " fname = gets.chomp err_try += 1 retry # jump to begin end ensure # do ensure block no matter what puts "Ensure close file" file&amp;.close # &amp;. -&gt; safer func call end rtnendputs "&gt;&gt; #&#123;get_file_first_line&#125;" inspect func — 自定義直接呼叫物件的回傳值。 12345678class Org def inspect "It's a Object" endendobj = Org.newobj # return "It's a Org" in irb]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>oop</tag>
        <tag>ruby</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP Note]]></title>
    <url>%2F2017%2F03%2F26%2FPHP-Note%2F</url>
    <content type="text"><![CDATA[這個世界上最好的語言，我學了很多次，但每次都是有需要才研究一下，感覺用完就生疏了， 在學完 OOP ，以及學了一些語言後，對這方面有些概觀，回來重新開始， 許多東西好像就合理了起來，但這次也只是複習基本語法罷了，期許能記得更牢。 Basic跟 Python 一樣是動態語言，所謂變數只是 name binding，用法跟 Python 也一樣，要用之前先 assign 一個值。變數前跟著一個 `，跟 Shell Script 不一樣的是 assign 的時候也要跟著 `。但是學到 OO 的部分，事情有了些變化，const 的東西不用加 $，或許是不把它當變數看的緣故。物件內的變數宣告，方法和 Python 蠻像的，但好像蠻強調 public 封裝。子函數習慣上也是用 $this 來設定 member variable。尚未探究子函數內是否有像 Cpp 用 scope 直接使用 member variable，但學到的是用 $this，所以可以用的可能性不大。但子函式又不像 Python 會把 self 傳進去。一般使用.作為字串 connect 的 operator，所以 object 呼叫底下的東西會用-&gt;。object 底下的變數不用再加錢號。 ex: $nobodyzxc-&gt;name 而不是 $nobodyzxc-&gt;$name。static 或 const 的東西可以用 ClassName::Attr呼叫，和 Cpp 一樣。 Functions簡單的 operator 略過。PHP 想當然爾，對文本的操作應是相當強的，但我也只學到 strlen() , strpos() , str_replace()，其他要用再查。html 轉碼、正則等之前用過幾次用用也忘了。自定義 function 寫法。1234function func_name($var)&#123; $rtn = blalala($var); return $rtn;&#125; 在函數裡宣告的變數基本上都是區域變數，如要用全域，加上global關鍵字。 Control Flow基本的東西，稍微記一下。12345678910111213141516171819202122232425262728if(exp)&#123;&#125;elseif(exp)&#123; // well , take care the key word&#125;else&#123;&#125;switch(what)&#123; case cs0: break; case cs1: break; case cs2: break; default: break;&#125;switch (what): // syntax sugar , pythonic ? case cs0: break; case cs1: break; case cs2: break; default: break;endswitch; Loop基本上和 C 系差不多，但有迭代器的用法 (Array 時再說），注意一下。12345678910for($i = 0 ; $i &lt; 10 ; $i++)&#123; echo $i;&#125;while(exp)&#123;&#125;while(exp): // syntax sugarendwhile;do&#123;&#125;while(0); Array物件化，沒有用符號下去載，直接拿一個物件名，注意 new。123456789101112131415161718$myArray = new Array(1 , 2 , 3);array_push($myArray , 4);unset($myArray , 3); // remove element 4unset($myArray); // remove whole arayforeach($myArray as $e)&#123; // iterator echo $e.'&lt;br&gt;';&#125;$twoDimAry = new Array(Array() , Array());$myAryMap = new Array('keyOne' =&gt; 1 , 'keyTwo' =&gt; 2 , 'keyThree' =&gt; 3);foreach($myAryMap as $key =&gt; $val)&#123; // array map iterator echo $key.' =&gt; '.$val;&#125; OOP寫個物件來記最快。123456789101112131415161718192021222324252627class Animal&#123; public $age;&#125;class Person extends Animal &#123; public $name; static public function say($word)&#123; echo $word.'&lt;br&gt;'; &#125; const die_age = 30; // we don't need $ public function __construct($age)&#123; $this-&gt;age = $age; &#125; public function getOlder()&#123; $this-&gt;age += 1; &#125;&#125;$nobodyzxc = new Person(20);echo $nobodyzxc-&gt;age;$nobodyzxc-&gt;getOlder();Person::say("there , there");]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>oop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL Note]]></title>
    <url>%2F2017%2F02%2F10%2FMySQL-Note%2F</url>
    <content type="text"><![CDATA[開篇謎之音：...... 寒假一直開坑，卻一直沒好好填。 之前想寫個 OJ 所以才接觸 MySQL，但一碰 MySQL 後 OJ 卻沒甚麼動力去玩了。 一切都靜止下來了。 一年後，突然想起，才在這裡慢慢填，主要是 w3school 的筆記。 利益相關：老爸是寫 ERP 管理資料庫的，然後他表示現在都用 stored procedure 了。 環境配置還是在 Cygwin 上，相關辦法可以參考不才的這篇。練習的 database 就用 w3school 教的 northwind 吧。12345git clone https://github.com/dalers/mywind.gitcat northwind.sql | mysql -u root -pcat northwind-default-current-timestamp.sql | mysql -u root -pcat northwind-data.sql | mysql -u root -p# -u 引數看你的配置 筆 (ㄉㄨㄟ) 記 (ㄐㄧ) 開始 create , show 123456789101112131415161718192021222324252627282930313233343536373839-- create database db_name;create database test;-- create table tb_name (column_1 data_type [constraint], ...)-- use test;-- create table custs;create table test.custs( id int , name varchar(255) , addr varchar(255) , city(255));show databases;show tables;-- add constraints// 1.alter table tb_nameadd constraint constraint_var_name constraint_type (cond | col_x)[references table_name(col_name)] -- foreign keyalter table tb_name// 2.add constraint_type (col_x) -- () is important-- add defaultalter table tb_namealter col_x set default val-- drop constraintsalter table tb_namedrop [index constraint_var_name | index col_x | primary_key | foreign key col_x | check col_x ]-- drop defaultalter table tb_namealter col_x drop default constraint list not null - col can’t be null unique - row for col must be unique primary key - not null union unique foreign key - ensure the key must exist in other table(ex: In order table have a foreign key customer , refers to customers table) check (cond) - check the condtition default (val) - assign the default val to col comment 1234567891011-- it's a comment , MySQL 3.23.3 supports ,-- I like the style becuase it's like haskell# it's also a comment/* inline comment *//*multiple linecomments*/ select [columns] from [database] 12select * from customers;select city from customers; distinct 12-- distinct the entryselect distinct city from customers; where [column] [value] 1select company from customers where id &lt; 10; op example note = &lt;&gt;[or!=] &gt; &gt;= &lt; &lt;= between select id , company from customers where id between 3 and 9 like select id , city from customers where city like ‘M%’; % 通配符 in select * from customers where id in (1 , 2 , 3 , 4) not and or order by [column] [asc|desc] , [column] [asc|desc] 1select id , company from customers order by id asc; insert into 12insert into strings values (1 , "String for id 1");insert into strings (string_id) values (115) update 12345-- revise value in entryupdate stringsset string_data = 'revised string_data'where string_id = 1;-- 注意要下 where 條件，不然會都改，和 where 1 = 1 一樣啦。 delete 123-- delete entrydelete from strings where string_id = 1;-- 注意要下 where 條件，不然會都刪，和 where 1 = 1 一樣啦。 limit 12345678-- MySQLselect * from strings limit 10-- Oracleselect * from strings where rownum &lt;= 10-- MS Accessselect top 10 * from strings wildcard wildcard meaning % likes * in shell _ likes ? in shell [] likes the char set that scanf supports [!] or [^] same as above alias 12select id as sn from customers;select c.id from customers as c; join inner join — 要有關聯才 show left join — 左邊全都 show ， 右邊看關聯 right join — 右邊全都 show ， 左邊看關聯 full join — 都 show , MySQL gg join — same as join12345select o.id as order_id , c.first_name as customerfrom orders as oinner join customers as con o.customer_id = c.idorder by o.id; union 123456789-- union two selectselect first_name from suppliersunionselect first_name from customers;-- union allow duplicate valuesselect first_name from suppliersunion allselect first_name from customers; select into , insert into 12345-- select entry insert to table [ in other db ] from origin_table-- but sadly , the method is from SQL.-- In mySQL , we should usecreate test.xs select * from stringsinsert into test.ss select * from strings create index 12-- accelerate the speed of searchingcreate [unique] index idx_name on tb_name (col_name) drop 1234567891011-- indexalter table tb_name drop index idx_name-- tabledrop table tb_name-- databasedrop database db_name-- clear the tabletruncate table tb_name alter table 1234567891011-- add colalter table tb_nameadd col_name data_type-- del colalter table tb_namedrop column col_name-- change typealter table tb_namemodify column col_name data_type auto_increment 12345678create table test.custs( id int not null auto_increment, name varchar(255) , addr varchar(255) , city(255));alert table test.custs auto_increment = 100; view 12345678910-- view is a virtual table , well , likes call by referencescreate view v_name as[ select statement ];-- updatecreate or replace view v_name as[ select statement ];-- dropdrop view v_name; date functions 12345678910select now() , curdate() , curtime() , date(now());-- extract(unit_value from date)select extract(hour from now()) , extract(minute from now());select date_add(now() , interval 2 day) , date_sub(now() , interval 2 day);select datediff(date_add(now() , interval 2 day) , now());select date_format(now() , "%Y-%M-%D-%a"); null 123456select * from tb_name where col_name is null;select * from tb_name where col_name is not null;-- ifnull or coalesce func let us def the rtn val when data is nullselect ifnull(address , "NULL ADDRESS") from tb_name;select coalesce(address , "NULL ADDRESS") from tb_name; type text char(size &lt; 255) - const length varchar(size &lt; 256) - var length , when over 255 -&gt; text tinytext - a string whose length &lt; 256 text - a string whose length &lt; 65536 mediumtext - a string whose length = 16777215 mediumbolb - to store bin obj , max size = 16777215 longtext - a string whose max length = 4,294,967,295 longbolb - a binobj whose max size = 4,294,967,295 enum(elm , …) - a list with max length = 65535 set - likes enum. wait me to find out. number (can add unsigned prefix) tinyint(size) - 1 byte smallint(size) - 2 bytes mediumint(size) - 3 bytes int - 4 bytes bigint - 8 bytes float - omit double - omit decimal - float represented by string date date - YYYY-MM-DD datetime - YYYY-MM-DD HH:MM:SS time - HH:MM:SS year - YYYY timestamp - YYYY-MM-DD HH:MM:SS (UTC) functions group by before order by MySQL doesn’t support first() , last() , alternatively , you should use order by and limit 12select ship_city from ordersgroup by ship_city order by id desc limit 1; having example: 12select ship_city from ordersgroup by ship_city having count(ship_city) = 4; mid(string , start from 1 , length) MySQL doesn’t support len() , you should use length()]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Haskell Note （Basic Syntax to Type）]]></title>
    <url>%2F2017%2F01%2F31%2FHaskell-Note%2F</url>
    <content type="text"><![CDATA[A world without loop , but recursion。 學校 PL 課程，及 Haskell 趣學指南 的一些心得筆記。 更新：戰場轉換到 scheme，scheme 新坑開完再回來。 更更新：我回乃了。 Some hints 不像 PP , OOP 告訴電腦要做什麼，FP 的思考方式是描述問題。 function call 有最高優先順序。 if 在 haskell 裡是 exp 不是 statment function name 字首必須小寫 (Type 為大寫）。 認清 ++ 和 : ，適時使用:，在前端插入元素。 List 的比較依照字典序。 Function list function Note + , - , * , / mod a b &amp;&amp; , &lt;/code&gt;&#124;&#124;&lt;/code&gt; , not == , /= &gt;, &gt;= , &lt; ,&lt;= max a b (a &gt; b ? a : b) min a b (a &lt; b ? a : b) succ a return ++a; a `func` b func a b (infixFunc) a b a infixFunc b if boolean then val else val boolean ? val : val ++ connect list : ins elm to list !! elm in list at idx head [t] first elm in list tail [t] a list contains all elm in origin list except head last [t] last elm in list init [t] a list contains all elm in origin list except last length [t] the len of list null [t] check the list is null , better then [t] == null reverse [t] reverse a list take num [t] a list contains the first num elm in origin list drop num [t] a list which is the origin list removes first num elms maximum [t] the max elm in a list minimum [t] the min elm in a list sum [t] the sum of all elm in a list product [t] the product of all elm in a list elem [t] check if the elm is in a list .. range , [elm .. elm] , [elm , elm .. elm]elm avoid using float (cycle [t]) a list of cycling orign list (repeat elm) a inf list made by a elm replicate num elm same as take num (repeat elm) [ valOfFunc &lt;/code&gt;&#124;&lt;/code&gt; var* &lt;- [t] , boolean(Guard)* ] _ = anonymous var list comprehension fst (t , t) the first elm in tuple(pair) snd (t , t) the second elm in tuple(pair) zip [t] [t] make a list of tuple(pair) (\var -&gt; valOfFunc) lambda exp zipWith (t->t’->t’’) [t] [t’] zip two list by a func flip (t->t’’->t’’’) flip the param order of a func call map (t->t’) [t] like for_each , list comprehension filter (t->Bool) [t] like Guard in list comprehension takeWhile t->Bool [t] take elm to return a new list while … foldl (t->t’->t) t [t’] do … to acc while elm \= [] foldr (t->t’->t) t’ [t] almost simialr to foldl foldl1 (t->t->t) [t’] take head of list as init foldr1 (t->t->t) [t’] almost simialr to foldl1 scanl (t->t’->t) t [t’] acc operated val to list from left scanr (t->t’->t) t’ [t] acc operated val to list from right scanl1 (t->t->t) [t] omit scanr1 (t->t->t) [t] omit Datatype Type Note Bool Int Integer Big Num , operations are not efficient as Int Float Double Char Maybe Nothing or single elm structure Structure Note List [] Tuple () Typeclass不禁讓我想到統計的三個 data Type , interval , odinal , categorical。 =&gt;符號左邊是型態約束（表示此 Type Var 屬於哪個 Typeclass)，右邊是引數和回傳值。用於描述函式原型 (?)。 例如將一般數字型態轉為更通用的 Integral 的函式 fromIntegral其定義為 fromIntegral :: (Num b, Integral a) =&gt; a -&gt; b Typeclass Feature Example type support func Note Eq 可判斷相等 Int … == Ord 可排序 Int … &gt; , &lt; , &gt;= , &lt;= , compare 有 Eq 特性 Show 可轉字串 Int … show Read 可由字串轉 Int … read 注意聲明，否則型態推導可能沒辦法 work Enum 順序可枚舉 Int … .. , succ , pred Bounded 有上下界 Int … minBound , maxBound 若 Tuple 內皆為 Bounded ， 則此 Tuple 亦有 Bounded 特性。 Num 數字類型 Int … fromIntegral Integral 整數類型 Integer fromIntegral Floating 浮點數類型 Float Pattern matching 順序很重要 函式定義內對參數的 pattern matching一開始提到的是可以在 .hs 中像 select case 全部啪出來，不用 if else，在 ghci 需要用 guard。其實是 case of 的語法糖。 函式引數和參數的 pattern matching其實就是參數可以將引數拆開（我用詞好精準 >///&lt;)，好用。 List Comprehension 的 pattern matching指南的例子 : [a + b | (a , b) &lt;- xs] 以上前兩點是我亂叫的，意思知道就好。（奪門而出 還有一種 at pattern , xs@(a:as)，表示把 xs 拆成 (a:as)。 Guard &amp; Key words123456789101112131415161718func param | [bool exp] = val | [bool exp] = val --let keyword(can be anywhere) | [bool exp] = let [name binding;...;...] in [exp] ... | otherwise = val --where keyword(must be the structure end) where [name binding] [function def balala]--let keyword in list comprehension[nameCanSee | nameCannotSee , let [name binding]][nameCannotSee | nameCannotSee , let [name binding] in [bool exp]]func param = case [exp] of [pattern] -&gt; val [pattern] -&gt; val [pattern] -&gt; val High Order Function Curried functions = 不完全的 functionex: 123456ghci &gt; tkMaxCmpWithTen = max 10ghci &gt; tkMaxCmpWithTen 910ghci &gt; addThree = (+3)ghci &gt; addThree 1013 High Order function = take function as parameter (Or return a function) 12345ghci &gt; applyTwice func x = func (func x)ghci &gt; applyTwice addThree 1016ghci &gt; applyTwice (+3) 1016 $ and . 123456$ comb to rightf(g(x)) = f . g $ xsum . map (*3) $ [1..9](int)sum(list) . (list)map (*3)(list) $ (list)[1..9] Module引入函式庫。12345678--in .hsimport Data.Listimport Data.List hiding (nub) --ignore nub in moduleimport Data.List (nub，sort) --only import num 'n sortimport qualified Data.Map --need use 'Data.Map.func' to call funcimport qualified Data.Map as M --can alias 'Data.Map' to 'M'--in ghci can also use:m Data.List Our own data type 永遠不要在 data 聲明中加型別約束 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465-- Object method-- data Typename = valueConstructor param ...data Circle = Circle Float Float Float-- Enum method-- data Typename = v0 | v1 | v2 ...data Day = Mon | Tue | Wed | Thu | Fri | Sat | Sundata Point = Point Float Floatdata Shape = Circle Point Float | Rectangle Point Pointmodlue Shape( Point (..) -- export all value constructor, Shape (Circle , Rectangle) -- export Circle and Rectangle, surface -- function name, baseCircle -- auxilliary function , baseCircle :: Float -&gt; Float -&gt; Shape) where-- 可以選擇不導出 value constructor，這樣強迫使用者使用 auxilliary function，-- 避免使用者直接對 value constructor 做 pattern matching，一個封裝的概念。-- record syntax avoid writting boring "get functions"data Person = Person &#123; firstName :: String , lastName :: String , age :: Int , height :: Float , phoneNumber :: String , secCrush :: String &#125; deriving (Show)ghci &gt; secCrush me"\x4a\x79\x75\x6e\x2d\x59\x69\x20\x4a\x68\x61\x6e\x67"-- derivingdata Day = Mon | Tues | Wed | Thur | Fri deriving (Eq , Ord , Bounded)-- type key word to alias typetype String = [char]type IntMap v = Map Int v-- same astype IntMap = Map Int-- operator-- infix[lr] seq symbolinfixr 5 ++-- an example of binary search treedata Tree a = EmptyTree | Node a (Tree a) (Tree a) deriving (Show, Read, Eq)singleton x = Node x EmptyTree EmptyTreetreeInsert x EmptyTree = singleton xtreeInsert x (Node a left right) | x == a = Node x left right | x &lt; a = Node a (treeInsert x left) right | x &gt; a = Node a left (treeInsert x right)treeElem x EmptyTree = FalsetreeElem x (Node a left right) | x == a = True | x &lt; a = treeElem x left | x &gt; a = treeElem x rightmkTree ls = foldr treeInsert EmptyTree ls typeclass123456-- 先前有介紹過 TypeClass，在這裡我們為自己的資料型態加上 TypeClassdata Day = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday deriving (Eq, Ord, Show, Read, Bounded, Enum)-- Eq 可比 , Ord 排序由左至右分別是小到大 , Show &amp; Read 提供 IO , Bounded 提供上下界 , Enum 順序枚舉-- 因為 Enum 的特性，可以使用[minBound .. maxBound] :: [Day] type key word and the type constructor12345678-- type 提供了一個對類別不錯的 alias 方法type String = [Char] -- 最常見的-- 我們寫 Function 在宣告可能會用到-- type constructortype AssocList k v = [(k,v)]-- 用法嘛，宣告用（應該不只這樣，再想想）[(1,2),(4,5),(7,9)] :: AssocList Int Int Questions? tuple likes struct , while list likes array ? 那就是右摺疊可以處理無限長度的資料結構，而左摺疊不可以。（因為 Lazy Eval 所以 foldr 可以跑出結果，foldl 會無窮）1234head' :: [a] -&gt; ahead' = foldr1 (\x _ -&gt; x)last' :: [a] -&gt; alast' = foldl1 (\_ x -&gt; x)]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>fp</tag>
        <tag>haskell</tag>
        <tag>lambda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim Note （Basic Manipulation）]]></title>
    <url>%2F2017%2F01%2F22%2Fvim-0%2F</url>
    <content type="text"><![CDATA[結識 vim 一年多了，一切的一切算得上機緣巧遇。 想來不禁百感交集，意味悠遠。 這篇文章會不定期更新，隨著我的 vim skill。 這段旅途的終點，大概就是我不用 vim 的那天吧！ （可能是入 emacs 教，或是奔向 IDE 了吧～) Chrome 有 Vimium ， Firefox 有 VimFx 加入我大 Vim 教吧。 基本操作篇要編輯一個存在的文檔tst.txt時只要在 terminal 下 vim tst.txt。如果要建立一個新檔，叫做new.txt，也只要下 vim new.txt，只是離開記得存。如果還沒想到要存什麼名字，只要下vim就好了，離開再命名就好了。 vim 有三種模式 normal , insert , visual。一開始進到 vim 時即是 normal 模式。 &lt;ESC&gt;進 normal mode ，normal mode 下，i（注意是小寫），可以讓游標在原位進入 insert mode，normal mode 下，v，可以進入 visual mode。 看起來，normal mode 是一切 mode 的橋樑。 敏銳的人可以發現， normal mode 左下並沒有特別的東西。insert mode 會出現 -- INSERT --， visual mode 則是 -- VISUAL --。 - normal modenormal 模式主要有兩種功能，快速移動游標、簡易文檔操作和下指令。其中離開指令就是在 normal mode 下的。要切換 normal mode 只要按esc鍵就好了，vim script 會表示成&lt;ESC&gt;。要下指令，只要在 normal mode 按:，再下指令。 移動 要移動最簡單的就是按方向鍵，但是 vim 習慣上會使用 jkhl ， 分別對應上下左右。（方向鍵在所有模式是通用的） 不想一格格移動的話可以先鍵入一個數字再移動，比如 15j 是向下移動十五行。在很多操作下都有搭配數字的用法，有興趣不妨試一下。 要把游標移動到行首，可以直接按數字 0。要把游標移動到行尾，可以直接按符號 $(shift + 4)。要把游標移動到首行，可以直接按字母 gg。要把游標移動到尾行，可以直接按字母 G(shift + g)。 vim 上某些建議是不要鎖住 caps lock 鍵，要大寫盡量用 shift 鍵。 文檔操作 copy : 整行 copy 按 yy，或是按v進入 visual mode 選取再按 y。 paste : 按p。 delete : 用法跟 copy 很像，字母d和x，try 一下吧，帶有剪下的功能。 search : 按下 / ， 鍵入搜尋字串然後enter，n下一筆，N上一筆。 replace: :%s/ 目標字串 / 取代成字串 /g，g是對每行的目標字串替換，沒加只會取代每行第一個。 （亦可進入 visual 進行取代，就不用使用%) （關於 vim regex 請走這） 指令 進到 vim 之後先講一下離開吧。有句有名的話是這樣說的。 要產生一個隨機字串，就是讓一個新手離開 vim 離開的指令是q，所以假設我們不知道現在是什麼模式， 只要按下&lt;ESC&gt;:q，就能離開。不過你可能會遇到這種情況 E37: No write since last change (add ! to override) 意思就是你對檔案有了改動， vim 不確定你是否要儲存再離開，所以詢問。道理和用 Word 離開會跳出 msgbox 一樣。如果沒有要儲存，照著提示，只要下:q!，即可。若要儲存，只要下:wq。到了這裡，有沒有發現一件事，所謂指令，好像有著某種組合關係。 沒錯， vim 的精隨就在於組合！ 像是要把該行往下 shift 一行，就可以使用 ddp。 w是儲存的指令，:wq，就是儲存後離開。直接下:w當然就是儲存啊，養成隨時儲存的習慣， vim 因為斷線掛掉可是很折騰的。 不要只會:wq啊，:w要舉一反三直接理解 前面提到，若沒取檔名，只要在離開使用:wq filename即可存成該檔並離開。filename 這個參數主要是餵給 w 使用，所以單獨用:w filename也可以。 若 vim 在一開始就開檔了呢？這時此種用法就會變成另存新檔囉，很好理解吧。 !是強制的意思，:q!，解釋為強制離開。有時是文檔的擁有者，但是沒有給自己加上 w 權限，這時 vim 左下角就會出現[readonly]。normal mode 下 :wq時就會出現 W10: Warning: Changing a readonly file 這時也只要加個驚嘆號就可以了。（當然，不是文檔擁有者不管用）那:qw可以執行嗎？很遺憾，所謂指令是有順序的，想想看，這合理嗎？也是可以試試看，程序員鼓勵試錯精神。 :wq 有快捷，他等價於:x，但我覺得要按&lt;ESC&gt;的話，計入移動手的成本，其實也沒快到哪裡。還有個快捷是ZZ。 normal mode 已經說了個大概，更進階的之後會在 vimrc section 中討論。 - insert mode主要就是打字，沒什麼好說的，有幾種指令可以由 normal mode 進入 insert mode。 i : 由游標位置進入。 I : 插入該行第一個字元位置。 a : 游標位置往後一位插入。 A : 插入行尾。 o : 插入下一行。 O : 插入上一行。 s : 消除一字元並進入。 S : 清除該行。 - visual mode 一鍵縮排很實用，選起來再按 = 即可。 所以要全文縮排就可以使用 ggvG= 或是 gg=G。 還有值得一提的是 column 模式。 按v進入 visual mode，往下選取需要的行。 ctrl-v進入 column 模式。 然後可以做啥咧？按I進入 insert mode，鍵入幾個字。 esc 跳出。 在每行插入剛剛打的字母。 參考資料：vim cheat sheet]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Memoir - Road]]></title>
    <url>%2F2016%2F12%2F31%2FMyRoad%2F</url>
    <content type="text"><![CDATA[謹記我跌跌撞撞，那不成熟的過去。 路？元旦連假回家，老爸載著我，吃晚餐的路上。 “唸到現在，你還會想念電機嗎？”，爸提了個問題。 “還好，只是不知道念電機的話現在會怎樣”“不過可能沒辦法像現在一樣方便，上個網找個方向就能充實專業”，我想想了後說。 “那樣就要像我一樣買單芯片機，一些材料，動手實作吧”，爸說。 “那樣很麻煩吧？”，我不禁嘆道。 憶當初選志願時，對資訊甚是排斥，主要是因為高中有過挫折吧。 高中電腦課學 C++ ，當時適應非常不良。對於using namespace std及cin &gt;&gt; , cout &lt;&lt;，感到沒有 sense。這些老師僅是帶過，我是有聽沒有懂，由於沒有深入講解，我對整個架構觀念，建立不太起來。 一切是如此的抽象。 對於引入頭文件云云感覺都記不太起來，可能是不太熟練吧。 但畢竟住宿，也沒有電腦可以搞這些。 對於沒辦法操作的程式，要我光看課本複習，我是辦不到的。 而結果是每次上課，我都只能生硬的使用這些東西，對於這一切一切，我感到非常恐懼，一種對陌生感到的恐懼。 一個段落寫完，運行不起來，底下錯誤訊息也不會看，老師好像也沒教。 總之，感覺要完成一段可以跑的東西，困難重重，一個不會就杵在那裏。 常常只能向老師求救，對自己的無能感到厭惡。 連 cout、cin 的 &lt;&lt; 及 &gt;&gt; 都常常寫反。 每每使用這些東西，我都會感到痛苦。 在這堂課中，我體會不到編程的樂趣，沒有成就，只有挫敗感。 記得曾向老爸抱怨聽不懂，他只是表示你現在只要把書讀好，不用去搞那些。 就這樣渾渾噩噩了三年 升大學的暑假，老爸教了我 VB6 ，我開始對程式開發產生了些興趣，也終於能開始熟練的使用簡單的語法了。 比起那時 Dev C++ 視窗裡的天書般的除錯訊息，VB6 更是直接的標示出有問題的地方。 而且不用引入函式庫， syntax 的 support 感覺強很多。 物件都帶有各自的屬性，一切具體了起來，OBP 帶我看到更結構化的世界，也為我鋪好了 OOP 的道路。 程式原來是嚴謹但不失彈性的，我深刻的體會到了這點。 “你怎麼會這樣寫捏？” 彷彿又回到了兩年前，老爸竟然說出了和電腦老師一模一樣的話。 但是這次我已可以好好說出我的想法，而不是當年的支支吾吾。 看著老爸拉著元件，加上程式碼，我好像可以了解到一些程式碼後的行為。 感覺經歷一兩年的沉澱，思路終於和這領域銜接上了，每個問題好像都能問到點上。 拉著表單，為各式各樣的元件加上程式碼，一切的一切如我所願的跑了起來。 程式能終於照著我的想法去跑了。 遇到 bug 我也終於看得懂錯誤訊息。 更重要的是學會了設中斷點，逐行運行程式，學會調試。 感覺 VB6 比 C++ 親切很多，語法檢查，錯誤提示，對我來說都點到了點上。 學習不再窒礙，我可以的，這是一個我可以掌握的世界。 上了大學學了 C 語言，感覺自己看了夠多，兩種語言間 (C/C++ , VB) 能互相輝映。剛碰 C ，就深深感到他比 C++ 親切，感覺少了很多奇怪的東西。 有了先前的經驗，我覺得即使再複雜，只要能跟我說明其中含意，我就能好好記住他。 好，那就開始吐槽 C 和 C++ 吧，我覺得用 C 入門比 C++ 好的一些點。 雖然說總的來說是我高中時不認真成分居多。（其實 VB6 才是最好入門的啊） `#include` vs `#include` 恩，我覺得前者比較有 sense ， 標準的 io 嘛，那 stream 是什麼鬼 ( murmuring ) `using namespace std;` 這個我不知要怎麼說了，完全沒有頭緒啊。 可能你跟我講沒有用的話，`cout`要改成`std::cout`，我就會有 sense 了。 `scanf("%c%d") printf("%c%d")` vs `cin >> cout `與`]]></content>
      <categories>
        <category>Memoir</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Markdown Note]]></title>
    <url>%2F2016%2F12%2F22%2FMarkdown%2F</url>
    <content type="text"><![CDATA[工欲善其事，必先利其器啊，既然 hexo 使用了 Markdown 來渲染文章，那就趕快來學個。 所謂 Markdown 是種輕量級標記語言，透過簡單的語法便可將.md 轉成.html。 等等！看來我對 Markdown 有誤解， 它的目的在於作為一個網路**寫作**用語言，重點在讓文檔**易讀易寫**， 至於轉成 html 是為了易於發布（當然嘛，瀏覽器讀的是 html)， Markdown 宗旨是讓寫作變得容易，所以沒有 html 這麼多花招， 當然，要用 html 的東西，直接用就是了（直接上 tag）， 其實渲染器說穿了就是文本替換罷了... 吧？ 剛好之前對 html 有些涉獵，所以 Markdown 在做些甚麼大抵上也是摸的到的。 所以學完 Markdown 後，我應該也可試試寫個渲染器（咦？) 0. 轉義進入各類用法前，先來個提要吧，遇到 Markdown 有歸為特殊用法的符號時，如果要讓它顯示原本的意思，就需要轉義，這時只要加一個反斜線\，在前就好了。 1. 標題先來個所謂的”起手式”，也是 html 都會教的第一課，就是標題啦~html 的標題是用&lt;h[1-6]&gt;&lt;/h[1-6]&gt;（就是 h1 到 h6)，轉成 Markdown 用#號表示 用法1234567# \# is equal to h1h1 還可以用這樣===============## \#\# is equal to h2h2 也可以用這樣---------------### \#\#\# is equal to h3 記得井號後要空格 效果 # is equal to h1h1 還可以用這樣## is equal to h2h2 也可以用這樣### is equal to h3 2. 內文html 的內文 tag&lt;p&gt;&lt;/p&gt;，在 Markdown 即是一個簡單文章的區段，不用特別加符號，&lt;p&gt;&lt;/p&gt;的開合用空行即能達成 用法1就是一個簡單的內文，用 f12 確認一下吧 效果就是一個簡單的內文，用 f12 確認一下吧 3. 強調html 的強調用法有斜體&lt;i&gt;&lt;/i&gt;、粗體&lt;b&gt;&lt;/b&gt;、刪除線&lt;s&gt;&lt;/s&gt;，Markdown 分別是使用*或_、**或__、~~ 用法123456*我是斜體呦* _我也是斜體_**我是粗體呦** __我也是粗體__*__兩個混著用__* _**注意遞迴式包裝**__**剩下的兩種**_ *__我也幫你試過了__****這種呢我也試*** ___我猜是不行___~~刪除線是這樣，混著用我就不試了~~ 效果我是斜體呦 我也是斜體我是粗體呦 我也是粗體兩個混著用 注意遞迴式包裝剩下的兩種 我也幫你試過了這種呢我也試 我猜是不行刪除線是這樣，混著用我就不試了 誒誒，竟然可以？! 我錯了（逃不行，這時不能逃，才學到一半（正經臉有點好奇底線是怎樣，結果發現好像是 style/CSS 的坑，標記語言不用理 4. 清單html 的清單… 沒記錯的話，最外層都是要先包一層&lt;li&gt;&lt;/li&gt;，再來看是要列順序 (ordered) 的&lt;ol&gt;&lt;/ol&gt;，還是要&lt;ul&gt;&lt;/ul&gt;就看尼囉。Markdown 對於&lt;ol&gt;就編個號，例如1.就好，&lt;ul&gt;可以用*、+或-。 用法123456789基本上不用理會 li 的存在，Markdown 會判斷，恩，我猜的（逃巢狀清單的話用縮排達成。跟標題一樣，注意編號和*+- 號後要空格1. 第一大條 * 一大的無序一中 * 一大的無序二中2. 第二大條 1. 二大的有序一中 2. 二大的有序二中 * 二大二中的無序一小 效果 第一大條 一大的無序一中 一大的無序二中 第二大條 二大的有序一中 二大的有序二中 二大二中的無序一小 5. 超鏈結再來就是 html 最重要（我覺得）的超鏈結啦~，複習一下 html 全名 HyperText Markup Languagehtml 的超鏈結就是&lt;a&gt;&lt;/a&gt;tag，在 Markdown 可以用[]()及[][] + []:使用 用法12345678910111213141516171819202122&lt;a href=&quot;超鏈結&quot; title=&quot;標題（可略）&quot;&gt;超鏈結名稱&lt;/a&gt;[超鏈結名稱](超鏈結 &quot;標題（可略）&quot;)標題就是滑鼠一到鏈結上面會顯示的東東啦當然，超鏈結也可以用相對路徑啦，寫過網頁的就知道了example:[It&apos;s a google link](https://www.google.com)[nobodyzxc github](http://github.com/nobodyzxc &quot;你瞅啥&quot;)這邊有種特殊用法，就是參考鏈結，有點像註腳，個人覺得像是變數[超鏈結名稱][參考名稱]『參考名稱』: 超鏈結如此一來，他的參考名稱就會去參考到超鏈結。兩行可以放得很開，第二習慣放最後面，當註腳（的樣子）。example:[知乎][zhihu 注意大小寫，這是一個變數參考 0]many lines[zhihu 注意大小寫，這是一個變數參考 0]: http://zhihu.com 效果It’s a google linknobodyzxc github 知乎many lines 6. 註腳“聽說！”生成 html 時會變成清單，放在檔案最下面，或是變成視窗跳出來，不太一定用中括號加^數字，[^0] 用法123註解零 [^0][^0] 就是這樣嗎？一樣要注意空格啊 效果註解零 00 就是這樣嗎？ Text prior to footnote reference.22 Comment to include in footnote. WTF? 好像弄不太起來… 有需要再找吧… 7. 圖片敘述最少的一個，超鏈結前加驚嘆號 用法123![my logo](https://avatars0.githubusercontent.com/u/17202064?v=3&amp;s=460)![看山醬萌萌噠][ref][ref]: /images/zhi.jpg &quot;zhi~~侵刪呦&quot; 效果 Image from zhihu、看山微博 8. 程式碼區塊如果鑲嵌行間請用` 前後包裝，一大塊則用```包（可以加語言名稱） 用法12345678行間鑲嵌一個 &bprime;/&bprime; \`\`\`C#include&lt;stdio.h&gt;int main(void){// 對 我是不換行派的，打我啊 return 0;}\`\`\` 效果行間鑲嵌一個/ 1234#include&lt;stdio.h&gt;int main(void)&#123;// 對 我是不換行派的，打我啊 return 0;&#125; 不要問我```是怎麼打出來的，我絕對不會說```&lt;/code&gt;是借助 html 和反斜線之力完成的。 9. 表格恩，就是 html 的&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;等 用法123456789冒號用來對齊（擺左齊左、擺右齊右，都擺置中）| editor | intro | comment ||---------------|:---------:|-------------------:|| emacs | 神的編輯器| 聽說這表格他很會畫 || vim | 編輯器之神| 本人目前用此編輯器 |最左最右的 | 不一定需要表格內部亦支援 Markdown 格式 效果 editor intro comment emacs 神的編輯器 聽說這表格他很會畫 vim 編輯器之神 本人目前用此編輯器 10. 引言電子郵件或論壇常見到的咚咚&gt; 用法1&gt; 引言 效果 引言 11. 內嵌 html不用多說，用下去就對了。 12. 水平分割線用法123456獨立一行，大於等於三個符號接起來即可-----------***********___________ 效果 凌晨四點… 我睡了… 本文的 Markdown 版本在這裡，晚安 reference 一本 gitbook domain name 像官網]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My new Site]]></title>
    <url>%2F2016%2F12%2F11%2Fnew-site%2F</url>
    <content type="text"><![CDATA[我所追求的簡單，終於在 github 上實現了，莫名感動。 能用 vim 寫自己的部落格，感覺更是難以言喻。 如果當初沒有用 cygwin，我大概就不會用 git，沒有 git 就不會頻繁地上 github， 沒上 github 就不會弄 git pages，沒弄 git pages 就不會使用 hexo，沒有 hexo 就不會有這篇貼文。 這一切的一切都是緣分啊！ 正好，pixnet 寫的有點煩，新型態的紀錄方式，希望能帶給我更多獨特的體驗。 首先要學好的是 Markdown 吶... 自己的空間好像有點... 氾濫（笑），所以打算來個區隔。 pixnet 就放些實作成果，這裡就放些自己學習足跡吧。 一趟新旅途的展開，加油吧！少年。]]></content>
  </entry>
</search>
